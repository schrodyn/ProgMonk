the programming mechanism that executes a series of statements repeatedly a
given number of times, or until a particular condition is fulfilled, is called
a loop.

The for Loop:

```c
int count;
for(count = 1 ; count <= 10 ; ++count)
printf("\n%d", count);
```

The first control expression is executed only once, when the loop starts.
This is the expression `count = 1`.

The second control expression must be a logical expression that produces a result
of true or false; in this case, it’s the expression `count <= 10`.
this expression is evaluated at the beginning of each loop cycle.
If it is true, the loop continues, and if it is false, the loop ends.


The third control expression, ++count in this case, is executed at the end of
each iteration.
Here you use the increment operator to add 1 to the value of count.


You can omit any of the control
expressions, but if you do you must still include the semicolon:

for example,
```c
int count = 1;
for( ; count <= 10 ; ++count)
	printf("\n%d", count);
```

The general pattern of the for loop is as follows:
```
for(starting_condition; continuation_condition ; action_per_iteration)
	Statement;
Next_statement;
```

The starting_condition usually (but not always) sets an initial value to a
loop control variable.
You can also declare and initialize several variables of the same
type here with the declarations separated by commas;
in this case all the variables will be local to the loop and will not exist once
the loop ends.


Here’s an example of a loop with two variables declared in the first loop control condition:
```c
for(int i = 1, j = 2 ; i<=5 ; i++, j = j+2)
	printf("\n %5d", i*j);
```

##The Prefix and Postfix Forms of the Increment Operator

the operator `++` in front of the variable to which it applies -- This is called the
prefix form. The operator can also be written after the variable to which it
applies, and this is referred to as the postfix form.

If you write `count++` in an expression, the incrementing of the variable count
occurs after its value has been used.

```c
/* sum of the first count numbers  */
for(int i = 1; i <= count; sum += i, i++);

for( ;; )	/* Indefinite loop */

printf("Do you want to enter another value? (Y or N): ");
scanf(" %c", &answer); /* Read response Y or N
if(tolower(answer) == 'n') /* look for any sign of no */
	break;		   /* Exit from the loop */


printf("\nYou have %d tr%s left.", count, count == 1 ? "y" : "ies");
```

##Generating Pseudo-Random Integers:

you can do that using the `rand()` function that’s declared in the `<stdlib.h>`
header file:

```c
int chosen = 0;
chosen = rand();	/* Set to a random integer */
```

Each time you call the `rand()` function, it will return a random integer.
The value will be from 0 to a maximum of `RAND_MAX`, the value of which is defined
in `<stdlib.h>`.

The sequence of numbers that’s generated by the `rand()` function uses a starting
seed number, and for a given seed the sequence will always be the same.

However, C provides another standard function, `srand()`, which you can call to
initialize the sequence with a particular seed that you pass as an argument to the function. This function is also declared in the `<stdlib.h>` header.

the `time()` function that’s declared in the `<time.h>` header file.
The `time()` function
returns the number of seconds that have elapsed since January 1, 1970, as an
integer

The `time()` function requires an argument to be specified that you’ll specify as
NULL. NULL is a symbol that’s defined in `<stdlib.h>`

Thus to get a different sequence of pseudo-random numbers each time a program is
run, you can use the following statements:

```c
srand(time(NULL));	/* Use clock value as starting seed */
int chosen = 0;
chosen = rand();	/* Set to a random integer 0 to RAND_MAX */
```

The simplest approach to obtaining values
in the range is like this:

```c
srand(time(NULL));
int limit = 20.0;	/* Upper limit for pseudo-random values */
int chosen = 0;
chosen = rand()%limit;
```

Of course, if you want numbers from 1 to limit, you can write this:

```c
chosen = 1+rand()%limit;	/* 1 to limit inclusive */

for(int n = 1 ; n<1000 ; n = n+7)
	sum += n;
```

You aren’t limited to a single loop control expression.

```c
for(int n = 1 ; n<20 ; sum += n, n += 2);
```

You aren’t limited to just two expressions either. You can have as many expressions here as you like, as long as they’re separated by commas.

##Floating-Point Loop Control Variables

```c
double sum = 0.0;
for(double x = 1.0 ; x<11 ; x += 1.0)
	sum += 1.0/x;
```

while loop:
```c
while(i <= count)
  sum += i++;
```

This is one situation in which the goto can be very useful because it provides a
way to avoid all the complicated logic. For example

```c
for(int i = 0 ; i<10 ; ++i)
 for(int j = 0 ; j<20 ; ++k)
  for(int k = 0 ; k<30 ; ++k)
  {
	/* Do something useful */*
	if(must_escape)
	  goto out;
  }

out: /*Statement following the nested loops */
```

The do-while Loop:
```c
int number = 4;
do
{
 printf("\nNumber = %d", number);
 number++;
}
while(number < 4);
```

The general representation:
```
do
  Statement;
while(expression);
```

Notice the semicolon after the while statement in a do-while loop.

You can try out the do-while loop with a little program that reverses the digits
of a positive number:

```c
temp = number; /* Copy to working storage */
```

This is necessary, because the process of reversing the digits destroys the original value, and you want to
output the original integer along with the reversed version.

The reversal of the digits is done in the do-while loop:
```c
do
{
	rebmun = 10*rebmun + temp % 10; /* Add the rightmost digit */
	temp = temp/10; /* Remove the rightmost digit */
} while(temp); /* Continue while temp>0 */*
```

```c
for(int day = 1; day<=7 ; ++day)
{
if(day == 3)
continue;
/* Do something useful with day */
}
```

This loop will execute with values of day from 1 to 7.
When day has the value 3, however, the continue statement will execute,
and the rest of the current iteration is skipped and the loop continues with the
next iteration when day will be 4.

How can you get the program to wait?

One way is to use another standard library function. The library function `clock()` returns the `time` since the program started, in units of `clock` ticks.
The `<time.h>` header file defines a symbol `CLOCKS_PER_SEC` that’s the
number of `clock` ticks in one second.

```c
now = clock();
for( ;clock() - now < CLOCKS_PER_SEC; ); /* Wait one second */
```

You also need to decide how you can erase the sequence of computer-generated
digits. This is actually quite easy. You can move to the beginning of the line by
outputting the escape character '\r', which is a carriage return.

All you then need to do is output a sufficient number of spaces to
overwrite the sequence of digits.

Note: The keyboard buffer is memory that’s used to store input from the keyboard. The `scanf()` function looks in the keyboard buffer for input rather than getting it directly from the keyboard itself.

With standard input and output—that is, from the keyboard and to the screen—there
are actually two buffers: one for input and one for output.
The standard input and output streams are called stdin and stdout respectively.

Now that you know how to identify the buffer, how do you remove the information
in it? Well, there’s a standard library function, `fflush()`, for clearing out
buffers.

Although this function tends to be used for files.

You simply tell the function which stream buffer you want cleared out by passing
the name of the stream as the argument.

```c
fflush(stdin); /* Flush the stdin buffer */
```

The declaration required for the function `fflush()` is in the `<stdio.h>` header
file

to determine when a character is printable -- you can use the `isgraph()` function
that’s declared in `ctype.h`
