everything is objects
interpretator (not compile)
assignment =
arithmetics: +, -, *, /, **

print methods: print, puts
strings:
	methods: .length, .reverse, .upcase, .downcase, .capitalize
	

comments: #
	multiline: =begin "..some stuff.." =end
	example:
	 =begin
	  I'm a comment!
	  I don't need any # symbols.
	 =end
	#No space beetween = and "begin" !!!

weecan make chains of nunctions:
	name.method1.method2.method3
	
example:
	"FlYp".downcase.reverse.upcase

gets input from the user:
variable_name = gets.chomp 
		=begin
		 gets getting input, Ruby automatically
		 adds a newline after each input
		 chomp removes that extra line
		=end

printing variables:
first_name = "Kevin"
puts "Your name is #{first_name}!"

formatting with string methods:
print "This is my question?"
answer = gets.chomp
answer2 = answer.capitalize 
answer.capitalize!

! modifies the value contained within the variable {answer} itself
equal to answer = answer.capitalize

if statement:
------------
if 4 < 25
    puts "I will be winner!"
end

we need "end" construction


if 4 < 25
    puts "I will be winner!"
else
    puts "No worry! You are already the winner!"
end

x = 7
if 4 < x
    puts "I will be winner!"
elsif 4 > x
    puts "No worry! You are already the winner!"
else
    puts "Almost all done!"
end

unless statement:
unless hugnry
  puts "I'm writing Ruby programs!"
else
  puts "Time to eat!"
end

problem = false
print "Good to go!" unless problem

x = 2
y = 2
if x == y
  print "x and y are equal!"
end

is_true = 2 != 3

is_false = 2 == 3

test_1 = 17 > 16

test_2 = 21 < 30

test_3 = 9 >= 9

test_4 = -11 < 4


You can also use logical or boolean operators. Ruby has three: and (&&), or (||), and not (!). Boolean operators result in boolean values: true or false.

if we want to check whether the user's input contains an "s":
if string_to_check.include? "substring"

We can do that using Ruby's .include? method, which evaluates to true if it finds what it's looking for and false otherwise.

When we find "s", we may want Ruby to replace every instance of "s" it finds with "th". We can do this with the .gsub! method, which stands for global substitution.

The syntax looks like this:

string_to_change.gsub!(/s/, "th")

Remember, you want the ! at the end of the method name so that Ruby will change the string in-place.

----------------------
print "Enter your string"
user_input = gets.chomp

user_input.downcase!

if user_input.include? "s"
    user_input.gsub!(/s/, "th")
    puts "Hello, #{user_input}!"
else
    print "No s strin!"
end

while statement:
-------------------------

counter = 1
while counter < 11
  puts counter
  counter = counter + 1
end

i = 1
while i <= 50 do
    print i
    i += 1
end

until statement:
------------------------

counter = 1
until counter > 10
  puts counter
  counter += 1
end

for statement:
------------------------

for num in 1...10
  puts num
end

three dots "..." tells Ruby to exclude the final number in the count
if we use two dots ".." this tells Ruby to include the final number

interator:
------------------------

i = 20
loop do
  i -= 1
  print "#{i}"
  break if i <= 0
end

next keyword:
-----------------------

For instance, if we don't want to print out the even numbers, we can write:

for i in 1..5
  next if i % 2 == 0
  print i
end

arrays:
-----------------------

my_array = [1, 2, 3, 4, 5]

.each iterator:
-----------------------

A more useful iterator is the .each method, which can apply an expression to each element of an object, one at a time. The syntax looks like this:

object.each { |item| # Do something }
ne way to loop
numbers.each { |item| puts item }

# another way to loop
numbers.each do |item|
  puts item
end

For instance:
-------------

array = [1,2,3,4,5]

array.each do |x|
  x += 10
  print "#{x}"
end

another example:
----------------

numbers = [1, 2, 3, 4, 5]

# one way to loop
numbers.each { |item| puts item }

# another way to loop
numbers.each do |item|
  puts item
end

-----------------
odds = [1,3,5,7,9]

odds.each {|x| print x*2}

-----------------
odds = [1,3,5,7,9]

odds.each {|x| print x*2}

-----------------
odds = [1,3,5,7,9]

odds.each {|x| print x*2}

.times iterator:
----------------

The .times method is like a super compact for loop: it can perform a task on each item in an object a specified number of times.

For example, if we wanted to print out "Chunky bacon!" ten times, we might type

10.times { print "Chunky bacon!" }


.split method
-------------

we want to divide the user's input into individual words.

Ruby has a built-in method for this called .split; it takes in a string and returns an array. If we pass it a bit of text in parentheses, .split will divide the string wherever it sees that bit of text, called a delimiter. For example,

text.split(",")

------------------

letters = ['a', 'b', 'c', 'd']
letters.each do |letter|
  print letter
end


Access by Index:
----------------

array = [5, 7, 9, 2, 0]
array[2]
# returns "9", since "9"
# is at index 2

Array of arrays:
----------------
multi_d_rray = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]

Hashes:
-------

my_hash = { "name" => "Eric",
  "age" => 26,
  "hungry?" => true
}

puts my_hash["name"]
puts my_hash["age"]
puts my_hash["hungry?"]

it's a literal notation
that because you literally describe what you want in the hash: you give it a name and you set it equal to a bunch of key => value pairs inside curly brackets iterating over.

You can also create a hash using Hash.new, like so:
my_hash = Hash.new

Adding to a Hash:
-----------------

pets = Hash.new
pets["Stevie"] = "cat"
# Adds the key "Stevie" with the
# value "cat" to the hash

Iterate hashes:
---------------

friends = ["Milhouse", "Ralph", "Nelson", "Otto"]

family = { "Homer" => "dad",
  "Marge" => "mom",
  "Lisa" => "sister",
  "Maggie" => "sister",
  "Abe" => "grandpa",
  "Santa's Little Helper" => "dog"
}

friends.each { |x| puts "#{x}" }
family.each { |x, y| puts "#{x}: #{y}" }

Iterating over arrays:
----------------------

numbers = [1, 2, 3, 4, 5]
numbers.each { |element| puts element }

Iterating over multidimensional arrays:
---------------------------------------

let's assume s = [["ham", "swiss"], ["turkey", "cheddar"], ["roast beef", "gruyere"]]

if we want to access "swiss" we can type s[0][1]
if we want to iterate through all items of all elements we could type:

s.each{|sandwich| sandwich.each{|item| puts item} }

Iterating over hashes:
----------------------
When iterating over hashes, we need two placeholder variables to represent each key/value pair:

restaurant_menu = {
  "noodles" => 4,
  "soup" => 3,
  "salad" => 2
}

restaurant_menu.each do |item, price|
  puts "#{item}: #{price}"
end

hash has a default value
------------------------
h = Hash.new("nothing here")


sorting by:
-----------

colors = {"blue" => 3, "green" => 1, "red" => 2}
colors = colors.sort_by do |color, count|
  count
end
colors.reverse!

converting to string
--------------------

convert the value from a number to a string using .to_s.

Methods in Ruby:
----------------

def welcome
  puts "Welcome to Ruby!"
end

P.S. we can also use it (1..10).each { |i| puts i }

square(n)
  puts n ** 2
end

def double(n)
  return n * 2
end

output = double(6)
output += 2

BLOCKS

Blocks Are Like Nameless Methods

Blocks can be defined with either the keywords do and end or with curly braces ({}).

Example:

1.times do
  puts "I'm a code block!"
end

1.times { puts "As am I!" }


# method that capitalizes a word
def capitalize(string) 
  puts "#{string[0].upcase}#{string[1..-1]}"
end

capitalize("ryan") # prints "Ryan"
capitalize("jane") # prints "Jane"

[1, 2, 3, 4, 5].each { |i| puts 5*i }

Sorting

my_array = [3, 4, 8, 7, 1, 6, 5, 9, 2]
my_array.sort!

Comparison Operator

looks like this: <=>

It returns 0 if the first operand (item to be compared) equals the second, 1 if first operand is greater than the second, and -1 if the first operand is less than the second.

books = ["Charlie and the Chocolate Factory", "War and Peace", "Utopia", "A Brief History of Time", "A Wrinkle in Time"]

# To sort our books in ascending order, in-place
books.sort! { |firstBook, secondBook| firstBook <=> secondBook }

# Sort your books in descending order, in-place below
books.sort! {|firstBook, secondBook| secondBook <=> firstBook}

OBJECT ID
---------

The .object_id method gets the ID of an objectâ€”it's how Ruby knows whether two objects are the exact same object.

SYMBOLS
-------
:s_name

In Ruby, a string is mutable, whereas a symbol is immutable. That means that only one copy of a symbol needs to be created. Thus, if you have

x = :my_str
y = :my_str
:my_str will only be created once, and x and y point to the same area of memory.

sounds = {
  :cat => "meow",
  :dog => "woof",
  :computer => 10010110,
}

Symbols make good hash keys for a few reasons:

1. They're immutable, meaning they can't be changed once they're created;

2. Only one copy of any symbol exists at a given time, so they save memory;
3. Symbol-as-keys are faster than strings-as-keys because of the above two reasons.

Converting Between Symbols and Strings:
---------------------------------------

:sasquatch.to_s
# ==> "sasquatch"

"sasquatch".to_sym
# ==> :sasquatch

---------------------------------------

strings = ["HTML", "CSS", "JavaScript", "Python", "Ruby"]

# Add your code below!
symbols = []
strings.each do |language|
    symbols.push(language.to_sym)
end

---------------------------------------

the hash syntax has changed in Ruby 1.9
The good news is that the new syntax is easier to type than the old hash rocket syntax :)

Example:
movies = {
  one: "Santa Barabara",
  two: "Monica in the Sun",
}

SELECT FROM HASH
----------------

what if we want to filter a hash for values that meet certain criteria?
For that, we can use .select.

grades = { alice: 100,
  bob: 92,
  chris: 95,
  dave: 97
}

grades.select {|name, grade| grade < 97}
# ==> {:bob=>92, :chris=>95}

grades.select { |k, v| k == :alice }
# ==> {:alice=>100}

.select does not modify the hash.

Example 2
-----------------------


movie_ratings = {
  memento: 3,
  primer: 3.5,
  the_matrix: 5,
  truman_show: 4,
  red_dawn: 1.5,
  skyfall: 4,
  alex_cross: 2,
  uhf: 1,
  lion_king: 3.5
}
# Add your code below!

good_movies = movie_ratings.select {|name, rating| rating > 3}

Can we iterate over just keys or just values?

Of course yes.

Ruby includes two hash methods, .each_key and .each_value, that do exactly what you'd expect:

my_hash = { one: 1, two: 2, three: 3 }

my_hash.each_key { |k| print k, " " }
# ==> one two three

my_hash.each_value { |v| print v, " " }
# ==> 1 2 3

CASE STATEMENT
--------------

case language
when "JS"
  puts "Websites!"
when "Python"
  puts "Science!"
when "Ruby"
  puts "Web apps!"
else
  puts "I don't know!"
end

DELETE from Hash
----------------

to remove a movie/rating pair from our hash: we just write movies.delete(title)!


