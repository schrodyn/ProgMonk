javap -v Hello.class

jar cfe hwd.jar Hello Hello.class

jar cf hwd.jar Hello.class

$ jar tf hwd.jar 
META-INF/
META-INF/MANIFEST.MF
Hello.class

jar xf hwd.jar

javac -classpath lib.jar Hello.java
java -classpath lib.jar:hwd.jar Hello

JDK -- Набор инструментов для разработки Java-программ, включая 
компилятор

JRE -- Набор инструментов для запуска Java-программ, включая 
виртуальную машину

JVM -- Виртуальная машина Java

JIT -- Подход к реализации виртуальной машины, при котором байткод не 
интерпретируется, а компилируется в машинный код для исполнения 
аппаратным процессором

JAR -- Формат архива, в который обычно упаковывают Java-программы и 
библиотеки

Intellij IDEA:

psvm -- "public static void main" shortcut

sout -- "System.out.println" shortcut

Ctrl+Space -- suggestions

Ctrl+P -- show function parameters

Ctrl+Q -- quick documentation

javadoc -- instrument for code documentation generation

Comments:

// -- single-line comment
/* */ -- multi-line comment

/**
 *
 */ -- special comments which contain documentation

in javadoc we can use simple html-markup and some specific tags.
for example, @author, @version:

/**
 * @author Jackie Chan
 * @version 1.0
 */

/**
 * Program entry point
 *
 * @param args command-line arguments
 */
public static void main(String[] args) {

}


"Code conventions for the Java Programming Language" document
"Java Style Guidelines" document

http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html
http://cr.openjdk.java.net/~alundblad/styleguide/index-v6.html

Shift+F6 -- rename variable (refactor)


there are 2 variable types in Java: primitive and reference types.

primitive:
  * boolean
  * char
  * byte, short, int, long
  * float, double

reference:
memory location which contains object actual address

in java you can't take actual numeric address of an object and
make some arithmetic with it.

it guarantees that a reference variable contains valid object address
or null.

&, | -- полная схема вычислений (по сравнению с &&, ||)

numeric types:

  * byte 8 bits 
  * short 16 bits
  * int 32 bits
  * long 64 bits

all types are signed

NO signed or unsigned modificators!

In numbers we can add "_" for example:

int tenMillion = 10_000_000;

long tenBillion = 10_000_000_000L;

char -- 16 bits, 0.. 2^16 - 1

char represents symbol number in Unicode (UTF-16)

char hex = '\u03A9';



real types: 
			bits	sign	mantissa	exponent
  * float   32		1		23			8
  * double  64 		1		52			11


+-m * 2^e

float floatWithSuffix = 36.6f;
double doubleWithSuffix = 4d;

double exponential = -123.4e-2; (-123.4 * 10^-2)

type casts:

byte --> short --> int --> long

char --> int --> long

оператор приведения типа ()

при привидении более емкого целого типа к менее емкому целому
типу лишние старшие биты просто отбрасываются:

int intValue = 1024;
byte byteValue = (byte) intValue; 0


при привидении double к целому числу дробная часть просто 
отбрасывается:

double pi = 3.14;
int intFromDouble = (int) pi; 3

слишком большое по модулю число при привидении к целому превращается
в максимальное по модулю представимое целое число того же знака.
В данном случае:

float largeFloat = 1e20f;
int intFromLargeFloat = (int) largeFloat;

и, наконец, слишком большое double при привидении к float превращается
в бесконечность:

double largeDouble = 1e100;
float floatFromLargeDouble = (float) largeDouble;


Классы-обертки 

boixing value (unboxing value)

int primitive = 0;
Integer reference = Integer.valueOf(primitive);

int backToPrimitive = reference.intValue();

классы-обертки полезны в нескольких случаях: например, для того, 
чтобы хранить числа и символы в коллекциях. Стандартные коллекции
в java не поддерживают примитивные типы, поэтому приходится
превращать их в объекты.

Во-вторых, классы-обертки могут пригодиться, когда нужно выразить 
в программе факт отсутствия значения: для этого вместо переменной
примитивного типа вы заводите переменную соответствующего ссылочного
типа и храните в ней либо null, либо ссылку на значение.

конвертация в строку и обратно:

long fromString = Long.parseLong("12345");

String fromLong = Long.toString(12345);

String concatenation = "area" + 51;

полезные методы: (лучше заглянуть в исходники)

short maxShortValue = Short.MAX_VALUE;

int bitCount = Integer.bitCount(123);

boolean isLetter = Character.isLetter('a');

float floatInfinity = Float.POSITIVE_INFINITY;

double doubleNaN = Double.NaN;

boolean isNaN = Double.isNaN(doubleNaN);

##Объявление vs выделение памяти

Объявление переменной и выделение памяти под объект -- это два 
независимых действия

если просто объявить в программе переменную: например, типа BigInteger

BigInteger number;

то никакой объект в этот момент создан еще не будет.

Мы просто объявляем ячейку памяти, которая может содержать в будущем
ссылку на объект. 

Объект создается оператором new:

number = new BigInteger("12345");

Помимо выделения места в памяти оператор new вызывает конструктор:
это специальный метод, инициализирующий внутреннее состояние объекта
в соответствии с переданными ему параметрами.

##Массивы

int[] numbers;

String[] args;

boolean bits[];

компилятор разрешает и так, и так.

объявление переменной и выделение памяти под массив -- это отдельные
действия. Массив создается оператором new. Размер массива фиксируется
в момент создания и впоследствии не может меняться.

int[] numbers = new int[100];

String[] args = new String[1];

boolean[] bits = new boolean[0]; (it's valid)

new boolean[0] - это создание массива нулевой длины. Отсутствие данных
удобнее выразить массивом нулевой длины чем нулевой ссылкой null, т.к. массив нулевой длины не требует особой обработки (отдельные if'ы), а нулевая ссылка требует.

При создании массива все элементы автоматически инициализируются 
значениями по умолчанию: Для чисел и символов -- это нули, для
boolean -- это false, для ссылок -- это null.

Явно инициализировать свежесозданный массив нулями не требуется.

Если нужен массив с ненулевыми значениями, можно перечислить
значения всех элементов при создании:

int[] numbers = new int[] {1, 2, 3, 4, 5};

boolean[] bits = new boolean[] {true, false};

Тогда количество элементов в квадратных скобках указывать не нужно.
Размер массива будет определяться автоматически.

в некоторых случаях оператор new, имя типа и квадратные скобки
можно опустить, оставив только фигурные скобки с содержанием
массива:

Это работает только когда переменная объявляется и инициализируется
в одной строчке

char[] digits = {
		'0', '1', '2', '3', '4',
		'5', '6', '7', '8', '9'};  

в остальных случаях надо использовать полную запись с оператором new

int[] numbers = {1, 2, 3, 4, 5};
int arrayLength = numbers.length;


int firstNumber = number[0];
int lastNumber = number[arrayLength - 1];
int indexOutOfBounds = numbers[5];

в Java поддерживаются многомерные массивы:

int[][] matrix1 = new int[2][2];
int[][] matrix2 = {{1, 2}, {3, 4}};

int[] firstRow = matrix2[0];
int someElement = matrix2[1][1];

внутри хранится не как сплошной участок памяти

что позволяет иметь ступенчатые массивы:

int[][] triangle = {
		{1, 2, 3, 4, 5},
		{6, 7, 8, 9},
		{10, 11, 12},
		{13, 14},
		{15}};

когда строчки отличаются по длине.

int secondRowLength = triangle[1].length;

или даже некоторые строчки могут отсутствовать (null)

есть один случай, когда вместо квадратных скобок используется
многоточие:

Varargs

static int maxArray(int[] numbers) { ... }

static int maxVarargs(int... numbers) { ... }

это объявление метода, принимающего переменное количество параметров

в первом случае, чтобы передать аргументы, нам потребуется написать

maxArray(new int[]{1, 2, 3});

если же метод объявлен с многоточием, то мы можем написать гораздо
компактнее:

maxVarargs(1, 2, 3);

компилятор сам упакует параметры в массив и передаст в метод,
обычный массив сюда также можно передать

внутри метода maxVarargs работа с таким массивом ничем не будет
отличаться от работы с обычным массивом

##Сравнение двух массивов

Общее правило в Java заключается в том, что оператор == сравнивает
ссылки, то есть ссылаются ли две переменные на один и тот же
объект.

int[] a = {1, 2, 3};
int[] b = {4, 5, 6};

boolean equals1 = a == b;

это подходит не всегда, для сравнения объектов по содержимому в Java
обычно используется метод equals()

boolean equals2 = a.equals(b);

к сожалению, именно для массивов он не работает, точнее работает,
но также сравнивает ссылки

для сравнения содержимого есть метод equals() в классе Arrays

boolean equals3 = Arrays.equals(a, b);

он сравнивает массивы только на первом уровне вложенности, то
есть он отлично работает для одномерных массивов, но для
двух и более мерных он будет ошибаться

boolean equals4 = Arrays.deepEquals(a, b);

Как распечатать массив:

int[] a = {1, 2, 3};

System.out.println(Arrays.toString(a));

System.out.println(Arrays.deepToString(a));

##Строки Java

Строка -- это ссылочный тип, хранящий последовательность символов
произвольной длины

String hello = "Hello";
String specialChars = "\r\n\t\"\\";
String empty = "";

char[] charArray = {'a', 'b', 'c'};

String -- это не то же самое, что и char[], но их можно конвертировать
друг в друга

String string = new String(charArray);

char[] charsFromString = string.toCharArray();

В некоторых языках строки должны заканчиваться нулевым символом,
в Java это не так. Длина строки хранится в отдельном поле, поэтому
внутри строки можно свободно использовать нулевые символы:

String zeros = "\u0000\u0000";

Фундаментальное свойство строк Java -- это их неизменяемость.
Когда объект String создан, мы не можем поменять в нем ни один
символ, содержимое объекта останется таким навсегда. Мы можем
только читать содержимое строки, узнавать длину 

String s = "stringIsImmutable";

int length = s.length();

получать символы по индексам:

char firstChar = s.charAt(0);

проверять, содержит ли строка определенный суффикс, префикс или
подстроку

boolean endsWithTable = s.endsWith("table");

boolean containsIs = s.contains("Is");

Любое изменение строки связано с созданием нового объекта, поэтому
методы взятия подстроки:

String substring = s.substring(0, 6);

поиска и замены:

String afterReplace = s.replace("Imm", "M");

преобразование регистра:

String allCapitals = s.toUpperCase();

Все они возвращают новую строку результат.

Так же и конкатенация:

String hello = "Hello ";
String world = "world!";

String helloWorld = hello + world;

Компилятор преобразует это в следующее:

StringBuilder sb = new StringBuilder();
sb.append(hello);
sb.append(world);
String helloWorld = sb.toString();

Популярная ошибка при использовании строк -- это сравнение строк
при помощи оператора ==

Но надо запомнить, что в Java он всегда сравнивает ссылки, а не 
содержимое. Для сравнения содержимого есть метод equals:

boolean referenceEquals = s1 == s2;

boolean contentEquals = s1.equals(s2);

и для строк, в отличие от массивов, он работает, а также есть 
специальный метод для сравнения без учета регистра:

boolean contentEqualsIgnoreCase = s1.equalsIgnoreCase(s2);

Оператор switch, поддерживает ветвление по значениям типа char,
String, enum и по целочисленным типам, кроме long

switch (digit) {
	case 0:
		text = "zero";
		break;

	case 1:
		text = "one";
		break;

	// ...

	default:
		text = "???";
}

Обход всего массива или коллекции:

for (String arg : args) {
	System.out.println(arg);
}

можно указать операторам break и continue конкретный цикл, на который
они будут действовать, например, самый внешний:

boolean found = false;

outer:
for (int[] row : matrix) {
	for (int x : row) {
		if (x > 100) {
			found = true;
			break outer;
		}
	}
}

метки в Java существуют только для операторов break и continue, 
никакого goto нет


##Основы ООП

Каждый объект относится к какому-либо типу, или еще говорят, что
объект является экземпляром класса.

Классы часто соответствуют сущностям предметной области, в контексте
которой работает программа.

For example:

Client client = new Client();

Contract contract = new Contract();

Order order = new Order();

Заводя классы, мы на самом деле описываем предметную область и 
в каком-то смысле формируем тот язык, на котором наша программа
будет написана.

Класс -- это общее описание, схема того, как устроена сущность.
Например, у клиента должно быть имя, дата рождения, домашний адрес.
А объект -- это конкретный экземпляр класса с конкретным состоянием.

Client client = new Client();
client.setName("Vasily Pupkin");
client.setBirthDate("1990-06-13");
client.setAddress("Spb");
Order[] orders = client.getOrders();

понятия ООП:

Абстракция  -- Выделение важных сущностей и свойств реального мира для
их моделирования в программе.

Инкапсуляция -- Объединение внутри класса данных и операций с ними; 
защита данных и других деталей реализации от прямого доступа.

Наследование -- Возможность создания производных классов на основе 
существующих.

Полиморфизм -- Возможность использования производного класса там, где 
разрешен экземпляр базового класса; при этом вызываются методы, 
переопределенные в производном классе.

##Пакеты и модификаторы доступа

Если следовать духу ООП, то наша программа будет разбита на маленькие
классы, каждый из которых слабо связан с остальными и сильно 
специализирован, то есть решает одну задачу, а не делает все сразу.

Когда количество наших классов переваливает за 10, то возникает
потребность как-то наши классы упорядочивать и структурировать.
Для этого в Java есть пакет.

Принадлежность класса пакету обозначается директивой package
в самом начале исходного кода класса:

package org.code.java;

public class HelloWorld {
	// ...
}

Обычно это директива идет первой же строчкой, перед ней могу быть
только комментарии. С учетом, что класс HelloWorld находится
в этом пакете, полное имя класса будет org.code.java.HelloWorld

Когда запускается jvm командой java, то ей всегда нужно передавать
полное имя класса.

Если в файле несколько классов, то директива package действует на все.

При отсутсвии директивы package класс принадлежит пакету по умолчанию,
а полное имя класса совпадает с его коротким именем.

в java принято раскладывать исходники в соответствии с их пакетами.
Исходный код такого класса должен находиться в 
org/code/java/HelloWorld.java

То же справедливо и для скомпилированного byte-кода

Это важно для виртуальной машины, которая, когда ей потребуется 
загрузить класс с таким полным именем org.code.java.HelloWorld, будет
искать его строго в файле org/code/java/HelloWorld.class и нигде
больше.

Пакет задает область видимости класса, дргугие классы этого же
пакета могут обращаться к классу HelloWorld по его короткому имени.

Классы из других пакетов должны ссылаться на класс HelloWorld по его
полному имени, либо использовать директиву import.

package org.code.java.other;

import org.code.java.HelloWorld;

импортировать можно либо конкретные классы, либо все содержимое пакета
сразу, как например:

import java.util.*;

В любой java программе подразумевается неявный импорт всех классов
из пакета java.lang:

import java.lang.*;

Классы из этого пакета всегда доступны по их коротким именам.

Интересная особенность: Классы из пакета по умолчанию невозможно 
использовать из других пакетов даже при наличии явного импорта

Есть еще одна директива import static, которая позволяет импортировать
статические поля и методы, то есть в тексте программы можно будет 
обращаться к ним, не указывая имя класса.

import static java.lang.Math.sqrt;
import static java.lang.System.out;

sqrt(4);
out.println("foo");

также есть вариант со звездочкой

import static java.lang.Math.*;

который импортирует сразу все статические поля и методы из класса.

Директива import служит только для одной цели: она позволяет 
в исходном коде программы ссылаться на импортируемые классы по
их коротким именам. Никакой подстановки тела импортируемых классов
в файл c исходным кодом не происходит, то есть это не аналог
директивы include из C.

Когда программа исполняется в jvm, то все импортированные классы
также должны присутствовать в classpath.


Пакеты стандартной библиотеки, которые чаще всего используются:

  * java.lang
  * java.io
  * java.nio
  * java.math
  * java.time
  * java.util
  * java.util.regex
  * javax.xml
  ...


Классы стандартной библиотеки Java находятся в пакетах с префиксами
java и javax.

Помимо задания области видимости и предотвращения коллизий имен,
пакеты могут служить для группировки связанных классов внутри
программы.

Например, все классы, относящиеся к ядру, могут быть собраны в пакете
core (com.intellij.core)

Разнообразные утилитные классы в пакете util (com.intellij.ide.util),
подключаемые модули -- в пакете plugins (com.intellij.ide.plugins)

И еще одна функция пакетов -- это инкапсуляция на более высоком
уровне, чем классы: при помощи модификаторов доступа можно
сделать класс, метод или поле доступным только в переделах
пакета, то есть можно скрыть какие-то детали реализации внутри
пакета так, что они не будут доступны классам из других пакетов.

в Java есть 4 типа доступа:

  * public -- разрешен доступ отовсюду без ограничений
  * protected -- доступ разрешен только для классов наследников и
  для классов текущего пакета
  * отсутствие модификатора -- означает доступ только в пределах 
  пакета
  * private -- доступ только в пределах класса

public class ModifiersDemo {

	public static void visibleEverywhere() {}
	
	protected static void inSubclasses() {}

	static void inPackage() {}

	private void inClass() {}

}

модификаторы protected и private не применимы к классам верхнего 
уровня, их можно применять к вложенным классам

Также в некоторых контекстах отсутствие модификатора означает не
пакетную видимость, а что-то другое.

##Объявление класса

Итак, класс объявляется ключевым словом class с именем класса и
модификатором доступа. 

В случае класса верхнего уровня может использоваться модификатор 
public или модификатора может не быть, что означает видимость класса
в переделах пакета. Модификаторы private и protected здесь лишены
смысла.

В одном исходном файле друг за другом может быть объявлено несколько
классов, но public может быть только один из них, и его имя обязано
совпадать с именем файла.

package java.lang;

public final class Integer {

	// ...

}

Ключевое слово final при объявлении класса означает, что от данного
класса нельзя наследоваться.

Любой элемент программы (класс, метод, поле) может сопровождаться
javadoc-комментарием

Состояние экземпляра класса хранится в переменных членах класса,
которые в Java называются полями.

Объявление поля состоит из модификатора доступа, типа поля и его
имени:

package java.lang;

public final class Integer {

	private final int value;

	// ...

}

тут же можно присвоить полю начальное значение, которое поле будет
иметь во всех свежесозданных экземплярах класса.

если значение не будет указано, то будет использоваться значение
по умолчанию (0, null, false)

в данном примере поле объявлено как private, это типичная практика
в java. В большинстве случаев значения полей являются деталями 
реализации и должно быть скрыто.

Объекты должны взаимодействовать друг с другом посредством осмысленных
методов, а не обращаться напрямую к состоянию друг друга.

Модификатор final (у поля) означает, что значение поля можно присвоить
только один раз, после чего менять его будет нельзя.

 package java.lang;

public final class Integer {

	private final int value;

	public Integer(int value) {
		this.value = value;
	}

	// ...

}

явное присвоение можно сделать при объявлении поля:

private final int value = 0;

или в конструкторе

	public Integer(int value) {
		this.value = value;
	}

компилятор проверит, что к моменту выхода из конструктора значение
поля будет обязательно присвоено. Если это не так, то будет выдана
ошибка компиляции.

Кстати, модификатор final можно применять и к локальным переменным,
и к параметрам методов, смысл его от этого не меняется: значение
переменной может быть присвоено только однажды.

Конструктор -- специальный метод, вызываемый при создании экземпляра
класса.

То есть когда где-то в программе применяется оператор new.

new Integer(33);

Задача конструктора -- инициализировать состояние объекта и 
подготовить его к использованию.

Объявление конструктора состоит из объяыления:

  * модификатора доступа
  * и имени класса

конструктор может принимать параметры, как и любой другой метод.

this -- это ссылка на текущий экземпляр, в контексте которого
исполняется метод класса;

Когда в классе не объявлен ни один конструктор, то неявно создается
конструктор по умолчанию без параметров.
то есть даже если у класса нет явного конструктора, его экземпляр 
можно создать при помощи оператора new


если нужно запретить создание экземпляра класса, то нужно сделать
конструктор приватным (private):

package java.lang;

public final class Math {

	private Math() {}

}


В классе может быть несколько перегруженных версий конструктора
с разными наборами параметров, при этом из одного конструктора
можно вызывать другой:

package java.math;

public class BigInteger {

	public BigInteger(String val) {
		this(val, 10);
	}

	public BigInteger(String val, int radix) {
		// ...
	}

}

в Java не поддерживается механизм задания значений по умолчанию
для параметров методов, но при помощи перегрузки методов
и вызова одного метода из другого его можно успешно 
эмулировать.

jvm поддерживает специальный метод finalize(), который будет вызван 
сборщиком мусора, когда на объект больше нет ссылок

protected void finalize() {
	// cleanup
}

однако после многих лет (наступания на грабли) сообщество 
java-программистов пришло к консенсусу, что полагаться на эту
возможность не следует, потому что метод finalize будет вызван
в не предсказуемый момент времени и не из предсказуемого потока.

Если объекту все-таки нужна "очистка" (освобождение ресурсов), то 
для этого заводят обычный метод, чаще всего с именем close()

public void close() {
	// cleanup
}

package java.io;

public class FileInputStream {

	public void close() {
		// cleanup
	}

}

и ответственность за вызов этого метода возлагается на программиста.

объявление метода состоит из: модификатора доступа, типа возвращаемого
значения, имени и параметров; 

Метод исполняется в контексте конкретного экземпляра класса.

Метод может иметь модификатор final: это означает, что данный метод
не может быть переопределен в классах наследниках.

package java.lang;

public final class Integer {

	private final int value;

	public final int intValue() {
		return value;
	}

}

впрочем, в данном примере класс уже объявлен как final, поэтому 
расставлять final на всех методах  избыточно.

В классе может быть несколько перегруженных методов:

package java.lang;

public final class String {

	public int indexOf(int ch) {
		return indexOf(ch, 0);
	}

	public int indexOf(int ch, int fromIndex) {
		// ...
	}

}

с одинаковыми именами, но разными наборами параметров; с помощью
этого, например, можно эмулировать значения по умолчанию для
параметров.

поля и методы могут быть статическими.

Статический метод исполняется в контексте класса, а не экземпляра 
класса, поэтому он не имеет доступа к this и не статическим полям и
методам.

в комбинации с final модификатор static используется для объявления
констант:

package java.lang;

public final class Integer {

	public static final int MIN_VALUE = 0x80000000;

	public static int rotateRight(int i, int distance) {
		return (i >>> distance) | (i << -distance);	
	}

}

ключевое слово const, известное по другим языкам, в Java не поддерживается

package java.math;

public class BigInteger {

	public static final BigInteger ONE = valueOf(1);

	public static BigInteger valueOf(long val) {
		// ...
	}

}


Классы можно объявлять не только на верхнем уровне программы, но и 
в других классах.

##Вложенные классы

package java.util;

public class ArrayList<E> {

	Object[] elementData;

	public Iterator<E> iterator() {
		return new Iter();
	}

	private class Itr implements Iterator<E> {
		int cursor;
		// ...
	}

}

ArrayList<E> -- это коллекция, контейнер для однотипных элементов,
но, в отличие от массива, он может динамически изменять свой размер.

Когда требуется обойти и обработать все элементы коллекции, 
используется Iterator -- объект по очереди возвращающий каждый 
элемент коллекции.

iterator должен помнить коллекцию, которую он обходит, чтобы получать
ее элементы, а также хранить текущую позицию обхода.

Этого легко добиться, поместив определение класса итератора внутрь
класса ArrayList; каждый экземпляр итератора будет иметь свое
собственное состояние, хранящееся в его полях, а также неявную
ссылку на экземпляр внешнего класса ArrayList<E>, 

то есть из кода итератора можно напрямую обращаться к полям
экземпляра ArrayList, в том числе к private

Если вложенный класс снабжен модификатором static, то неявная связь
с внешним классом теряется, и экземпляры вложенного класса будут
жить своей собственной независимой жизнью:

package java.util;

public class Collections {

	public static final List EMPTY_LIST = new EmptyList<>();

	public static final <T> List<T> emptyList() {
		return (List<T>) EMPTY_LIST;
	}

	private static class EmptyList<E> {
		// ...
	}

}

при этом размещение одного класса внутри другого мотивируется либо
желанием скрыть вложенный класс, сделав его private, либо тесной
логической связью внешнего и вложенного класса, требующего тесный
доступ к приватным полям друг друга

Вложенный класс, объявленный с модификатором static, теряет возможность обращаться к нестатическим членам внешнего класса.

Перечисления объявляются ключевым словом enum:

package java.time;

public enum DayOfWeek {
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	SUNDAY	

}

перечисление -- это полноценный ссылочный тип, его можно воспринимать
как класс с фиксированным количеством экземпляров

перечисленные в enum значения эквивалентны public static final 
полям класса

более того в перечислениях можно объявлять поля и методы:

package java.time;

public enum DayOfWeek {
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	SUNDAY;

	// fields and methods	
}

Достаточно поставить ; и дальше объявлять поля и методы как в обычном
классе

Можно также объявить конструктор, в том числе принимающий параметры

в любом перечислении автоматически доступны методы name(), ordinal(),
а также статический метод values(): 
  * name возвращает строку, имя элемента перечисления как в исходном 
  коде
  * ordinal() возвращает число, порядковый номер элемента, начиная
  с нуля в соответствии с объявлением в исходном коде
  * values() возвращает массив возможных значений перечисления в
  том же порядке

##Наследование

Классы можно создавать не с нуля, а наследуя или расширяя другие
существующие классы. 

Наследование в java обозначается ключевым словом extends.
Наследоваться можно только от одного класса.

Унаследованный класс автоматически получает все поля и методы 
базового класса, пользоваться ими с учетом модификаторов доступа
может как он сам, так и другие классы программы.

В классе-наследнике можно добавлять поля и методы. Кроме того методы
можно переопределять, то есть в классе-наследнике можно завести метод
с таким же именем и параметрами, как в базовом классе, 
при этом тип возвращаемого значения должен либо совпадать, либо быть
подклассом типа возвращаемого базовым методом. А также модификатор
доступа должен быть одним и тем же, либо более открытым.

Если эти условия выполнены, то метод класса-наследника заменит
собой одноименный метод из базового класса.


package java.lang;

public final class StringBuilder
	extends AbstractStringBuilder {

	@Override
	public StringBuilder append(String str) {
		// ...
	}

	// base method in AbstractStringBuilder:
	// AbstractStringBuilder append(String str)

}

здесь StringBuilder переопределяет метод append, при этом
возвращаемый тип отличается, но переопределение является корректным,
так как возвращаемый StringBuilder является подклассом 
AbstractStringBuilder

а вот если бы здесь мы возвращали String или int, то код бы 
не скомпилировался.

хорошая практика ставить на переопределенных методах аннотацию
@Override, она явно декларирует ваше намерение переопределить
одноименный метод базового класса. Это может показаться 
избыточным, ведь переопределение происходит вне зависимости
от аннотации, однако это полезно для дополнительной самопроверки.

Например, можно ошибиться в имени метода или в его параметрах и, 
таким образом, создать самостоятельный метод, не перекрывающий
метод суперкласса, или объявление суперкласса может измениться
без вашего ведома, и сигнатуры методов разойдутся. При наличии
аннотации @Override компилятор сразу укажет вам на эту проблему.

условия, необходимые для того, чтобы метод производного класса 
переопределил метод базового класса:

  * Метод базового класса должен быть виден в производном классе.
  * Метод производного класса должен иметь в точности тот же набор 
  параметров, что и метод базового класса.
  * Метод производного класса должен иметь модификатор доступа, такой
  же или более открытый, чем метод базового класса.
  * Тип, возвращаемый методом производного класса, должен совпадать 
  или быть подклассом типа, возвращаемого методом базового класса.

Когда в классе отсутствует явное ключевое слово extends, то
подразумевается extends java.lang.Object

Object -- корень иерархии наследования, родитель всех ссылочных
типов, в том числе массивов, перечислений и аннотаций

public class Object {

	public String toString() {
		return getClass().getName() + "@"
			+ Integer.toHexString(hashCode());
	}

	public boolean equals(Object obj) {
		return this == obj;
	}

	public native int hashCode();

}

public final class String {

	@Override
	public boolean equals(Object anObject) {
		if (this == anObject) {
			return true;
		}
		if (anObject instanceof String) {
			String other = (String)anObject;
			// ...
		}
		return false;
	}
	// ...
}

Проверка типа обычно делается при помощи оператора instanceof, 
который проверяет, является ли объект, находящийся по ссылке,
экземпляром заданного класса, при этом подклассы тоже считаются.

По соглашению если в instanceof передать null, то он не должен 
падать, а должен вернуть false

hashCode представляется целым числом типа int, по своей сути он
нужен только лишь для того, чтобы объекты можно было хранить
в hash-таблицах

Существует требование на согласованность реализации методов equals
и hashCode, а именно если два объекта равны с точки зрения метода
equals, то у них обязаны быть одинаковые hashCode'ы

Если для каких-то объектов это правило нарушается, то вы не сможете
хранить эти объекты в hash-таблице, точнее сможете, но постоянно
будете получать неправильные результаты.

Поэтому рекомендуется либо переопределять одновременно и equals,
и hashCode, либо не переопределять ни один из них.

hashCode (в HotSpot) по умолчанию вычисляет hashCode'ы как 
псевдо-случайные числа, генерируемые и сохраняемые в объекте при 
первом вызове метода hashCode.


Где может использоваться модификатор final:

  *  В объявлении метода.
  *  В объявлении параметра метода.
  *  В объявлении локальной переменной.
  *  В объявлении нестатического поля класса.
  *  В объявлении статического поля класса.
  *  В объявлении класса. 


Пример переопределения equals и hashCode

public final class ComplexNumber {
    private final double re;
    private final double im;

    public ComplexNumber(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double getRe() {
        return re;
    }

    public double getIm() {
        return im;
    }
    
    @Override
    public boolean equals(Object anobject) {
        if(this == anobject) {
              return true;
        }
        if(anobject instanceof ComplexNumber) {
            ComplexNumber anComplex = (ComplexNumber) anobject;
            return this.re == anComplex.re && this.im == anComplex.im;
        }
        return false;
    }
    
    @Override
    public int hashCode() {
        return (int) (re * re + im * im);
    }
}

##Абстрактные классы и интерфейсы

Класс может соответствовать не только конкретной сущности предметной
области, но и какому-то абстрактному понятию, например, Shape --
абстрактная геометрическая фигура, просто геометрической фигуры
без типа существовать не может.

Для того, чтобы выразить это в программе, используется ключевое слово
abstract. Если класс объявлен как abstract, это означает, что нельзя
создавать его экземпляры, создать можно только экземпляры класса
наследника, не являющегося абстрактным.

В абстрактном классе может быть все, что в обычном: поля, 
конструкторы и методы, но некоторые методы могут быть абстрактными
(abstract), то есть без реализации

public abstract class Shape {

	private final Color color;

	public Shape(Color color) {
		this.color = color;
	}

	public Color getColor() {
		return this.color;
	}

	public abstract double getArea();

}

Все неабстрактные классы-наследники должны предоставить реализацию
данного метода.

Наличие абстрактных методов в неабстрактных классах приведет к
ошибке компиляции.

Абстрактные классы решают сразу две задачи: с одной стороны, они
определяют набор публичных методов, то есть по сути внешний контракт
данного класса, с другой стороны они могут содержать не публичные
поля и методы, то есть какие-то детали реализации.

Бывает так, что нам нужно описать только внешний контракт программной
сущности, не закладывая никаких деталей реализации. Предполагается,
что возможные реализации настолько различны, что не будут иметь
ничего общего между собой.

Например, сервис, который получает все заказы клиента по его id,
может быть реализован поверх реляционной базы данных или поверх 
xml-файла, содержащего все данные или, что удобно в тестах,
хранить все данные в памяти.

Чтобы описать такой сервис, мы могли бы завести абстрактный
класс, в котором есть только публичные абстрактные методы, однако
у конкретной реализации сервиса по объективной причине может
быть необходимость отнаследоваться от какого-то другого класса,
и это -- проблема, потому что в java множественное наследование
запрещено.

К счастью, решение есть. В качестве альтернативы абстрактному классу,
в котором все методы публичные абстрактные, в java введена отдельная
сущность -- интерфейс.

Все методы интерфейса по определению публичные и абстрактные,
поэтому явно писать данные модификаторы не требуется.

public interface OrderService {

	Order[] getOrdersByClient(long clientId);

}

поля в интерфейсе могут быть только публичные, статические и 
финальные, то есть по сути константы.

Ничего не публичного в интерфейсе объявить нельзя. Интерфейс
служит для объявления контракта объекта по отношению к внешнему миру.

Интерфейсы отличаются от абстрактных классов тем, что могут содержать
только публичные методы и публичные статические финальные поля.

Хотя в интерфейсе все же может быть какой-то исполняемый код.
Во-первых, могут быть статические методы, обязательно публичные.
Во-вторых, могут быть так называемые default-методы, то есть методы
с реализацией по умолчанию. Они были добавлены не случайно.
Представьте себе, что в программе объявлен интерфейс, который
предлагается реализовывать другим программистам. 

import java.time.LocalDate;

public interface OrderService {

	Order[] getOrdersByClient(long clientId);

}

Через некоторое время в интерфейс добавляется еще один метод 

import java.time.LocalDate;

public interface OrderService {

	Order[] getOrdersByClient(long clientId);

	Order[] getOrdersByClient(long clientId, LocalDate date);

}

для получения списка заказов по клиенту за конкретную дату, чтобы
по возможности не загружать в память лишние данные.

Что происходит в данный момент? У всех программистов, реализовавших
этот интерфейс, перестанет компилироваться код их классов, так как
появился нереализованный абстрактный метод. Чтобы этого не 
происходило, в интерфейсах добавили поддержку default-методов.

Разработчик интерфейса при добавлении нового метода может
задать реализацию по умолчанию, которая будет использоваться,
если в классе, реализующем интерфейс, этот метод не определен:

public interface OrderService {

	Order[] getOrdersByClient(long clientId);

	default Order[] getOrdersByClient(
				long clientId, LocalDate date) {
		Order[] allOrders = getOrdersByClient(clientId);
		return Orders.filterByDate(allOrders, date);
	}

}

Разумеется, остается возможность эту реализацию переопределить 
на какую-то более оптимальную.

Каким образом интерфейсы помогают решить проблему множественного
наследования? Оказывается, в java можно объявлять классы, реализующие
произвольное количество интерфейсов.

Реализуемые классом интерфейсы перечисляются после ключевого слова
implements:

public class OrderServiceImpl
		extends ServiceBase
		implements OrderService {

	public Order[] getOrderByClient(long clientId) {
		// ...
	}

}


Интерфейсы, в которых ровно один абстрактный метод, называются
функциональными, это можно дополнительно подчеркнуть, поставив
аннотацию @FunctionalInterface

При наличии данной аннотации компилятор проверит, правда ли в
интерфейсе единственный абстрактный метод, и если нет, то 
выдаст ошибку.

package java.lang;

@FunctionalInterface
public interface Runnable {
	
	void run();

}


package java.lang;

@FunctionalInterface
public interface Comparator<T> {
	
	int compare(T o1, T o2);

}

если первый объект меньше второго, то возвращается отрицательный int
если объекты равны, возвращается 0
если первый объект больше второго, возвращается положительный int

Функциональные интерфейсы обладают одним приятным свойством:
их реализацию можно компактно записать в виде лямбда-выражения или
ссылки на метод:

Предположим, что нам надо написать программу, которая замеряет
время работы различных вычислений, код замера времени хочется
написать один раз и затем переиспользовать, поэтому мы напишем
такой класс с методом measureTime, принимающим измеряемое вычисление
в виде экземпляра Runnable.

public class Timer {

	public long measureTime(Runnable runnable) {
		long startTime = System.currentTimeMillis();
		runnable.run();
		return System.currentTimeMillis() - startTime;
	}

}

метод System.currentTimeMillis() возвращает количество миллисекунд,
прошедшее с полуночи 1-го января 1970-го года.

import java.math.BigDecimal;

public class Main {

	public static void main(String[] args) {
		Timer timer = new Timer();
		long time = timer.measureTime(new BigDecimalPower());
		System.out.println(time);
	}

	private static class BigDecimalPower implements Runnable {
		
		@Override
		public void run() { new BigDecimal("1234567").pow(100000); }
	}

}

Получилось довольно громоздко, воспользуемся возможностью 
декларировать новые классы прямо в теле метода:

import java.math.BigDecimal;

public class Main {

	public static void main(String[] args) {
		Timer timer = new Timer();
		long time = timer.measureTime(new Runnable() {
		
			@Override
			public void run() { 
				new BigDecimal("1234567").pow(100000); 
			}
		});
		System.out.println(time);
	}

}

Вот так мы перенесли объявление класса прямо внутрь метода main,
и более того прямо внутрь выражения с вызовом метода measureTime

Здесь объявляется анонимный класс, реализующий интерфейс Runnable,
и сразу же создается его экземпляр. Этот класс анонимный, то есть
он не имеет своего имени, компилятор при компиляции программы сам
на свое усмотрение сочинит для этого класса какое-то уникальное 
имя.

Но это все еще довольно громоздко. До java 7 включительно с этим 
было ничего не поделать, но в java 8 была добавлена поддержка
лямбда-выражений, теперь этот же код можно переписать более
компактно:

import java.math.BigDecimal;

public class Main {

	public static void main(String[] args) {
		Timer timer = new Timer();
		long time = timer.measureTime(() -> new BigDecimal("1234567").pow(100000));
		System.out.println(time);
	}

}

Это лямбда-выражение: () -> new BigDecimal("1234567").pow(100000) 

Оно начинается с круглых скобок, в которых указываются параметры,
в данном случае метод run() не предполагает каких-либо параметров,
поэтому скобки пустые.

Кстати, параметры здесь указываются без типов, потому что типы
известны компилятору из объявления интерфейса.

После скобок идет стрелочка, а за ней тело лямбда-выражения.
В данном случае оно состоит из единственного выражения. Если
бы здесь было что-то более сложное, это надо было бы заключить 
в фигурные скобки {}.

Такое лямбда-выражение порождает объект, реализующий интерфейс
Runnable с указанным телом метода run().

Лямбдой можно заменить только реализацию функционального интерфейса,
то есть интерфейса с единственным абстрактным методом.

AsciiCharSequence:

```java


public class AsciiCharSequence implements java.lang.CharSequence {
    
    private byte[] byteArr;
    
    public AsciiCharSequence(byte[] byteArr) {
         this.byteArr = byteArr;   
    }
    
    public char charAt(int index) {
        return (char) byteArr[index];
    }
    
    public int length() {
        return byteArr.length;
    }
    
    public CharSequence subSequence(int start, int end) {
        byte[] buffer = new byte[end-start];
        for (int i = 0; i < end-start; i++) {
            buffer[i] = byteArr[start+i];
        }
        return new AsciiCharSequence(buffer);
    }
    
     
    public String toString() {
        char[] buffer = new char[byteArr.length];
        for (int i = 0; i < byteArr.length; i++) {
            buffer[i] = (char) byteArr[i];
        }
        return new String(buffer);
    }
    
    
}
```

##Исключения

Исключения -- это события, которые случаются в процессе работы
программы и прерывают стандартный ход ее исполнения.

Программа переходит в специальный режим поиска обработчика
внештатной ситуации. Такой обработчик может предпринять какие-то
действия и вернуть программу в штатный режим работы.
А если обработчика не нашлось, то jvm все-таки завершит программу,
но обеспечит достаточно подробный диагностический вывод.

Исключения поддержаны на уровне языка java. Кроме того они 
используются на уровне виртуальной машины, которая сообщает о многих
своих проблемах, бросая исключения.

И, разумеется, вся стандартная библиотека активно использует 
исключения.

Исключение в java -- это объект, экземпляр какого-то класса. Все
классы исключений наследуются от java.lang.Throwable, который
в свою очередь наследуется от Object.

Ключевое свойство экземпляров Throwable и его подклассов --
возможность быть "брошенными" при помощи оператора throw, бросание 
выглядит следующим образом: 

ключевое слово throw и за ним любое выражение типа Throwable

throw new IllegalStateException("Invalid user. " +
							"Please replace user and continue.");



в классе Throwable объявлены различные методы, перечислим некоторые
из них:

package java.lang;

public class Throwable {

	public String getMessage() { /* ... */ }

	public void printStackTrace() { /* ... */ }

	public StackTraceElement[] getStackTrace() { /* ... */ }

	public Throwable getCause() { /* ... */ }

	public Throwable[] getSuppressed() { /* ... */ }

	// ...

}

getMessage -- возвращает текстовую строку с описанием проблемы,
ее задача -- упростить диагностику проблемы, объяснить пользователю,
что именно произошло.

printStackTrace -- печает Stack Trace в stderr

getStackTrace() -- возвращает Stack Trace, то же, что печатается
в консоли, в виде массива java-объектов

StackTraceElement содержит имя класса, имя метода, имя файла и
номер строки, то есть Stack Trace можно получить и проанализировать

getCause -- он возвращает другое исключение, явившееся причиной
данного, или null, если данное исключение является первичным, а не
вызвано каким-то другим.

Если дойдет дело до печати в консоль, то будет распечатана вся 
цепочка исключений

getSuppressed -- этот метод возвращает одно или более исключений,
которые мы заглушили в процессе обработки основного исключения:

поясним на примере, представим, что мы читаем из файла, вдруг 
возникла ошибка ввода-вывода, вылетело исключение, мы начали
ее обрабатывать, попытались закрыть файл, но тут еще раз
случилось исключение, как их обрабатывать? Существует соображение,
что первое исключение обычно более важно, именно оно описывает
первопричину проблемы, а все остальное, что случилось потом,
с высокой степенью вероятности -- это последствие, поэтому первое
исключение терять точно не следует. С другой стороны, последующие
исключения могли быть совсем про другое и не связаны с первым,
поэтому совсем игнорировать их тоже не следует. Именно для
это существует массив Suppressed-исключений, одно исключение
выбирается в качестве главного, а остальные под него "подвешиваются"

##Классификация исключений

Исключения в Java делятся на 3 группы:

  * Исключительные ситуации в JVM
    java.lang.Error

  * Исключительные ситуации в пользовательском коде:

    * Проверяемые (checked)
    java.lang.Exception

    * Непроверяемые (unchecked)
    java.lang.RuntimeException


названия классов и их назначение:

  * java.lang.Throwable -- Базовый класс для всех исключений

  * java.lang.Exception -- Базовый класс для проверяемых исключений, 
  соответствующих ошибкам программной логики

  * java.lang.RuntimeException -- Базовый класс для непроверяемых 
  исключений, соответствующих ошибкам программной логики

  * java.lang.Error -- Базовый класс для исключений, соответствующих 
  ошибкам виртуальной машины

Задача: Реализуйте метод, позволяющий другим методам узнать, откуда 
их вызвали. Метод getCallerClassAndMethodName() должен возвращать 
имя класса и метода, откуда вызван метод, вызвавший данный утилитный метод. Или null (нулевую ссылку, а не строку "null"), если метод, 
вызвавший getCallerClassAndMethodName() является точкой входа в 
программу, т.е. его никто не вызывал.

	public static String getCallerClassAndMethodName() {
    	try {
     		throw new Exception();   
    	} catch(Exception e) {
        	StackTraceElement[] stackArr = e.getStackTrace();
        	if (stackArr.length <= 2) {
            	return null;
        	}
        	else {
            	return stackArr[2].getClassName() + "#" + stackArr[2].getMethodName();
        	}
    	}
	}


начиная с Java 7 стало возможно в одном catch блоке обрабатывать
несколько типов исключений, это удобно, когда исключения не
являются подклассами друг друга, но тем не менее должны 
обрабатываться одинаково:

try {
	// ...
} catch (FirstException e) {
	e.printStackTrace();
} catch (SecondException e) {
	e.printStackTrace();
}

// since Java 7 can be replaced with:
try {
	// ...
} catch (FirstException | SecondException e) {
	e.printStackTrace();
}

После try может быть еще один блок -- finally:

InputStream is = new FileInputStream("a.txt");
try {
	readFromInputStream(is);
} finally {
	is.close();
}

он выполнится в любом случае: было исключение или нет.
В этом блоке обычно занимаются освобождением ресурсов (закрытием
файлов, снятием блокировок). finally не является обработчиком
исключения, то есть если из блока try вылетело исключение,
то после отработки блока finally это исключение полетит дальше.

в Java 7 появилась новая конструкция try-with-resources, выглядит
эта конструкция следующим образом:

try (InputStream is =
		new FileInputStream("a.txt")) {
	readFromInputStream(is);
}

После ключевого слова try в круглых скобках выделяются ресурсы,
с которыми будет работать этот блок, их может быть несколько,
в таком случае они перечисляются через точку с запятой (;),
гарантируется, что при выходе из блока все ресурсы будут освобождены,
точнее, что на каждом из ресурсов будет вызван метод close().

Аналогично блоку finally это случится при любом раскладе, было 
исключение или не было, но в отличие от примера с блоком в finally,
здесь исключение из close не перебьет собой исходное исключение,
а будет добавлено в него в качестве заглушенного (suppressed).

то, что реально происходит в блоке try-with-resources 
(try с ресурсами) можно иллюстрировать следующим фрагментом кода:

InputStream is = new FileInputStream("a.txt");
try {
	readFromInputStream(is);
} catch (Throwable t) {
	try {
		is.close();
	} catch (Throwable t2) {
		t.addSuppressed(t2);
	}
	throw t;
}
is.close();

Кстати, ресурс -- это любой объект, реализующий интерфейс 
java.lang.AutoCloseable:

package java.lang;

public interface AutoCloseable {

	void close() throws Exception;

}

##Логирование

В стандартной библиотеке Java есть набор классов для организации
логирования, и, воспользовавшись ими, мы автоматически получаем
следующие бонусы: во-первых, точечную настройку логирования 
(включение/отключение на уровне отдельных пакетов или классов),
во-вторых, настройку уровня детальности логирования,
в-третьих, настройка места, куда логи будут писаться,
и в-четвертых, настройка форматов, в котором эти логи будут вестись.

Причем это может удобно настраиваться в конфигурационном файле.

Классы логирования лежат в пакете java.util.logging.*;

package org.example.logging;

import java.util.logging.*;

public class LogDemo {

	private static final Logger LOGGER =
		Logger.getLogger(LogDemo.class.getName());
	
	// ...
}

статический метод getLogger вовзращает Logger с указанным именем;
обычная практика: в каждом классе, где требуется логирование,
завести финальное статическое поле, куда положить логгер с именем,
соответствующем полному имени класса.

Такая практика с именованием логгеров в честь классов программы
неслучайна: во-первых, каждый класс получает свой индивидуальный
логгер, и появляется возможность управлять настройками логирования
с точностью до класса (для одного класса логирование включено,
для соседнего выключено), во-вторых, благодаря длинным именам,
разделенным точками, логгеры выстраиваются в иерархию в соответствии
с именами; в данном примере у нас есть класс LogDemo с 
соответствующем именем, а также логгеры-родители.

Обработка логируемых сообщений идет от конкретного логгера,
через которого сообщение брошено наверх к корню, и на каждом
уровне может быть какая-то своя обработка, например, на уровне 
org можно организовать вывод всех событий в какой-то специальный
log-файл.

На корневом уровне можно только выводить в консоль самые критические
ошибки.

Логгирование производится следующим образом:

LOGGER.log(Level.INFO, "I'm logging");

// SEVERE, WARNING, INFO
// CONFIG, FINE, FINER, FINEST

LOGGER.warning("We have a problem!");

уровень логирования -- это степень серьезности данного сообщения

INFO -- это информационное сообщение о нормальном ходе исполнения
программы;
есть два более серьезных уровня и четыре менее серьезных:

на уровне SEVERE логируются серьезные ошибки программы
на уровне WARNING логируются предупреждения
CONFIG предназначен для логирования каких-то конфигурационных
параметров,
а FINE, FINER и FINEST -- для совсем детального логирования,
что программа делает, вплоть до входа/выхода в методы и прочих
мелочей.

Для удобства на каждый уровень логирования в логгере есть
одноименный метод:

LOGGER.warning("We have a task!");

Он выбрасывает сообщения соответствующего уровня

Логгер можно сконфигурировать таким образом, чтобы он игнорировал
все сообщения с уровнем ниже заданного; например, логгер, настроенный
на уровень warning, будет принимать только сообщения с уровнем 
SEVERE и WARNING и отправлять в /dev/null все остальное.
Настройка делается либо в коде при помощи вызова метода 
setLevel(Level.WARNING), либо в конфигурационном файле.

LOGGER.log(Level.FINEST,
		"Current value of x is " + x); 

у этого подхода есть один недостаток, проявляющийся в программах,
работающих под большой нагрузкой: даже если логирование данного
уровня отключено, все равно программа постоянно будет заниматься
конкатенацией строк, поэтому был придуман другой способ:

передавать в метод log фиксированную строку, в которой специальным
образом обозначены места для подстановки, и отдельно передавать
значения, которые будут туда подставляться; если значение одно,
то оно передается непосредственно, а если их несколько то нужно
"завернуть" их в массив Object[]


LOGGER.log(Level.FINEST,
		"Current value of x is {0}", x);


LOGGER.log(Level.FINEST,
		"Point coordinates are ({0}, {1})",
		new Object[] {x, y});

Подстановка параметров в строку происходит внутри логгера и только
при условии, что указанный уровень логирования включен,
то есть строчка действительно попадет в лог и не будет выкинута

Отдельно поддерживается случай, когда в логе нужно получить
StackTrace распечатку исключения, для этого достаточно передать
в log исключение:

LOGGER.log(Level.SEVERE,
		"Unexpected exception", e);

Символы подстановки в сообщении при этом не нужны

Logger делегирует обработку в класс java.util.logging.Handler:

  * обработчик сообщения
  Определяет, куда будет записано сообщение

  * java.util.logging.ConsoleHandler
  * java.util.logging.FileHandler
  * java.util.logging.SocketHandler

handler задается в конфигурации или прикрепляется к логгеру вызовом
метода addHandler()

И еще один момент: в каком формате сообщение записывается в лог

java.util.logging.Formatter:

  * определяет формат вывода
  * java.util.logging.SimpleFormatter
  * java.util.logging.XMLFormatter

handler имеет ссылку на formatter и делегирует ему всю работу
по превращению залогированного сообщения в окончательный вид,
пригодный к выводу в файл или передачи по сети. В стандартной
библиотеке есть две реализации.

Почему рекомендуется выводить отладочную информацию при помощи класса
Logger, а не через System.out или System.err:

  * Logger дает возможность гибко настраивать формат и место записи 
  сообщений без изменения программы.

  * Logger позволяет менять детальность логирования, не прибегая к 
  if'ам в коде.

  * Logger поддерживает локализацию отладочных сообщений.

##Доступ к файловой системе

задачу доступа к файловой системе в java решает класс java.io.File

File networkFolder = new File("\\\\server\\share");

// on Unix
File mvExecutable = new File("/usr/bin/mv");

экземпляры класса File представляют файлы и директории на диске

экземпляры создаются при помощи конструктора, принимающего String
с путем; строка передается в формате, понятном текущей опер. системе

Если вы в программе формируете пути к файлам, то пользуйтесь
константами File.separator или File.separatorChar

разница между этими двумя константами в том, что 
separator -- это String, а separatorChar -- это char.
в данном случае нет разницы что использовать:

String sourceDirName = "src";
String mainFileName = "Main.java";

String mainFilePath = sourceDirName 
			+ File.separator
			+ mainFileName;


кстати, в классе File есть еще несколько полезных констант
pathSeparator и pathSeparatorChar -- это символ, которым разделяется
набор путей (в Windows -- ";" в Unix -- ":" )

Еще один способ собрать путь с правильным разделителем -- это
использовать конструктор File с двумя параметрами:

File mainFile = new File(sourceDirName, mainFileName);

он внутри себя склеит два компонента пути, используя нужный 
разделитель

Экземпляр класса File можно создать как с абсолютным путем,
так и с относительным:

File absoluteFile = new File("/usr/bin/java");
absoluteFile.isAbsolute(); //true
absoluteFile.getAbsolutePath(); // /usr/bin/java

абсолютный путь -- это путь, однозначно указывающий на файл,
начиная с корня файловой системы; относительный путь можно
превратить в абсолютный при помощи метода getAbsolutePath, 
возвращающего String, или аналогичного метода getAbsoluteFile, 
возвращающего экземпляр File; путь будет разрешен относительно
текущей директории java процесса, то есть из какой директории
была запущена jvm

File relativeFile = new File("readme.txt");
relativeFile.isAbsolute(); // false
relativeFile.getAbsolutePath();
// /home/man/readme.txt


File file = new File("/usr/bin/java");

String path = file.getPath(); // /usr/bin/java

String name = file.getName(); // java

String parent = file.getParent(); // /usr/bin

аналогично метод getParentFile возвращает не String, а в виде
экземпляра File

канонический путь:

File file = new File("./prj/../symlink");

String canonicalPath = file.getCanonicalPath();
	// "/home/man/readme"	
аналогично getCanonicalFile() (--> File)

метод getCanonicalPath приводит любой путь к каноническому виду:
сначала вычисляя абсолютный путь, затем вырезая из него все 
избыточные компоненты вроде "." и ".." и разрешая (резолвя) 
символические ссылки

Привидя два путя к каноническому виду, их уже можно сравнивать как
строки

##Работа с файлами

Существование объекта класса File не привязано к существованию
файла или директории на диске, конструктор File ничего на диске
не создает, таким образом путь спокойно может указывать на
несуществующий файл или директорию

у объекта есть методы для проверки существования и типа:

File java = new File("/usr/bin/java");
java.exists(); // true
java.isFile(); // true 
java.isDirectory(); // false

когда мы убедились, что это файл, и он существует, то можем
запросить по нему дальнейшую информацию, например, размер

java.length(); // 6480

или время последней модификации

java.lastModified();

в миллисекундах с с 1970-го года

если вдруг файл не существует, то методы length и lastModified будут
возвращать нули, а не будут бросать исключения

если экземпляр File соответствует директории, то мы можем получить
ее содержимое при помощи методов list и listFiles:

File usrbin = new File("/usr/bin");
usrbin.exists(); // true
usrbin.isFile(); // false
usrbin.isDirectory(); // true

usrbin.list(); // String[]
usrbin.listFiles(); // File[]

если мы запрашиваем содержимое не существующей директории, то
вместо массива нам вернется null

содержимое возвращается только на один уровень; если нужно получить
все содержимое, включая поддиректории, то придется руками написать
рекурсивный обход;

##Фильтрация файлов

Есть перегруженный варианты методов list и listFiles, принимающие
фильтр:

File[] javaSourceFiles = dir.listFiles(
			f -> f.getName().endsWith(".java"));

Фильтр -- это объект, реализующий интерфейс либо FileFilter,
либо FilenameFilter:

// java.io.FileFilter:
// boolean accept(File pathname)

// java.io.FilenameFilter:
// boolean accept(File dir, String name)

оба этих интерфейса содержат ровно по одному абстрактному методу
accept, поэтому их можно инстанцировать при помощи лямбда-выражения

наконец, мы добрались до методов, позволяющих что-то поменять
в файловой системе:

try {
	boolean success = file.createNewFile();
} catch (IOException e) {
	// handle error
}

первый такой метод createNewFile атомарно создает новый пустой файл,
он возвращает true если все прошло успешно, false -- если файл
уже существовал и создать его не удалось

он может бросить IOException, если, например, нет прав или не 
существует директория, в которой мы пытаемся его создать

метод createNewFile нужен в тех случаях, когда нам требуется 
убедиться, что файл создан именно нашей программой, именно сейчас,
чтобы случайно не начать писать в файл, созданный кем-то извне;
гарантируется, что проверка существования и создания этого пустого
файла происходит атомарно, то есть никакая другая программа или 
пользователь между этими двумя операциями вклиниться не может

Для создания директорий есть методы mkdir и mkdirs:

File dir = new File("a/b/c/d");

boolean success = dir.mkdir();

boolean success2 = dir.mkdirs();

Разница между ними следующая: метод mkdir за один вызов может
максимум создать одну директорию; если нам нужно создать
иерархию из четырех вложенных директорий, то метод mkdir с этим
не справится, нас спасет второй метод mkdirs, который за один
метод может создать все уровни вложенности

метод delete удаляет файл или директорию, возвращает true, если
все ок

boolean success = file.delete();

метод renateTo переименовывает файл, он принимает не строку с новым
именем, а экземпляр File, то есть при помощи этого метода можно
так переименовать файл, что он окажется в другой директории

boolean success = file.renameTo(targetFile);

Обратите внимание, что метода копирования в классе File вообще нет,
его нужно тоже либо писать руками, либо подключать из какой-то
сторонней библиотеки

Всер рассмотренные методы модификации ФС возвращают true в случае
успеха, false в случае, если что-то не получилось. Это, конечно,
не самое удачное решение проектировщиков стандартной библиотеки,
лучше бы все методы в случае проблем бросали исключения, как метод
createNewFile.

При текущем подходе приходится писать везде if-ы для проверки 
возвращаемого значения, во-вторых в случае ошибки нам неоткуда
взять информацию об ее причинах. К сожалению, изменить поведения
класса File теперь уже не представляется возможным из соображений
обратной совместимости, которая в платформе Java особо тщательно
поддерживается.

Осознавая все проблемы текущего API, его неудобства и недостатки,
разработчики Java 7 добавили абсолютно новый набор классов для 
работы с файловой системой. Новые классы живут в пакете
java.nio.file

и API более стройный: нет булевский флажков, методы бросают
исключения, кроме того новые классы предоставляют более широкий
набор возможностей: можно работать с расширенными атрибутами файлов,
например, с правами доступа или с владельцами, можно работать 
с символическими символами, в частности создавать их или узнавать,
куда ссылка ведет; ну и, конечно, появились методы перемещения
и копирования файлов

Аналог класса File в новом API -- это интерфейс java.nio.file.Path

Он также представляет собой путь к файлу или директории, построенный
по правилам текущей операционной системы:

Объект Path не привязан к существованию файла на диске, это, грубо
говоря, строчка, обернутая набором методов

экземпляры Path получаются через класс Paths и его статический
метод get:

Path path = Paths.get("prj/java");

также добавлены методы конвертации в File и обратно:

File fromPath = path.toFile();

Path fromFile = fromPath.toPath();

## Разбор пути

У интерфейса Path есть аналоги всех синтаксических операций,
присутствующих в классе File

Path java = Paths.get("/usr/bin/java");
java.isAbsolute(); // true
java.getFileName(); // java
java.getParent(); // /usr/bin

а также добавлены многие удобные методы, которых у File не было:

java.getNameCount(); // 3
java.getName(1); // bin
java.resolveSibling("javap"); // /usr/bin/javap
java.startsWith("/usr"); // true
Paths.get("/usr").relativize(java); // bin/java

Например, получение компоненты пути по его индексу или проверка того,
является ли один путь префиксом другого

java.startsWith("/usr"); // true

или вычисление относительно пути между двумя местами в файловой 
системе

## Работа с файлами

в интерфейсе Path в отличие от класса File нет методов доступа
к файловой системе, когда надо залезть на диск, то это делается
через класс Files и его статические методы:

там есть все аналоги операций, которые были в классе File
и даже больше:

Path java = Paths.get("/usr/bin/java");
Files.exists(java); // true
Files.isRegularFile(java); // true
Files.size(java); // 6480
Files.getLastModifiedTime(java).toMillis(); 

наконец, есть методы copy и move, не имеющие ограничений, связанных
с нахождением файлов на одной файловой системе

Files.copy(java, 
			Paths.get("/usr/bin/java_copy"),
			StandardCopyOption.REPLACE_EXISTING);

опционально туда можно передать дополнительные параметры, например,
что делать, если целевой файл уже существует 
(StandardCopyOption.REPLACE_EXISTING)

## Работа с директориями

в новом API заметно отличается получение содержимого директории,
теперь это делается при помощи отдельного объекта DirectoryStream,
получаемого при помощи статического метода Files.newDirectoryStream,
куда дополнительно можно передать фильтр:

Path usrbin = Paths.get("/usr/bin");
Files.exists(usrbin); // true
Files.isDirectory(usrbin); // true

try(DirectoryStream<Path> dirStream =
		Files.newDirectoryStream(usrbin)) {

	for (Path child : dirStream) {
		System.out.println(child);
	}

}

DirectoryStream представляет собой директорию, открытую на чтение,
это ресурс ОС, который надо освобождать, поэтому его стоит 
использовать в блоке try с ресурсами, который гарантирует вызов
метода close() при завершении блока

Этот код выглядит более громоздко, однако на то есть причины: 
директории бывают большими и не всегда хочется зачитывать их
содержимое в память сразу целиком; новый API позволяет обрабатывать
содержимое в потоковом режиме небольшими порциями

для создания директорий есть методы Files.createDirectory и
Files.createDirectories:

Path dir = Paths.get("a/b/c/d");

Files.createDirectory(dir);

Files.createDirectories(dir);

разница между ними такая же, как между методами mkdir и mkdirs в
классе File

Что касается удаления директорий со всем их содержимым, то такого
метода до сих пор нет, зато был добавлен общий механизм рекурсивного
обхода директорий, при помощи которого можно реализовать как 
удаление, так и копирование, и все остальное, что потребуется:

для этого есть метод Files.walkFileTree, который принимает 
директорию и объект, реализующий интерфейс FileVisitor;
в интерфейсе есть методы, вызываемые в процессе обхода,
например, перед входом в директорию, после выхода из директории
(postVisitDirectory), после нахождения файла (visitFile)

в данном примере мы воспользовались классом SimpleFileVisitor и
переопределили только два из четырех его методов; SimpleFileVisitor
сам по себе ничего не делает и удобен как раз в таких случаях,
чтобы от него унаследоваться и переопределить один, два метода

Path directory = Paths.get("/tmp");

Files.walkFileTree(directory, new SimpleFileVisitor<Path>() {

	@Override
	public FileVisitResult visitFile(
			Path file, BasicFileAttributes attrs)
			throws IOException {
		Files.delete(file);
		return FileVisitResult.CONTINUE;
	}

	@Override FileVisitResult postVisitDirectory(
				Path dir, IOException exc) throws IOException {
		if (exc == null) {
			Files.delete(dir);
			return FileVisitResult.CONTINUE;
		} else {
			throw exc;
		}
	}

});

FileVisitResult -- говорит, что делать дальше (остановиться, 
продолжить и пропустить)

## Виртуальные файловые системы

новый API не только более удобен и функционален, но и более гибко
устроен внутри; в частности, он позволяет программистам реализовывать
различные файловые системы. Например, в стандартной библиотеке
есть реализация файловой системы поверх zip-архива.

Мы открывает zip:

Path zipPath = Paths.get("jdk/src.zip");

и работаем с его содержимым как с обычными файлами при помощи тех
же классов

try (FileSystem zipfs = FileSystems.newFileSystem(zipPath, null)) {

	for (Path path : zipfs.getRootDirectories()) {
		Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
			
			@Override
			public FileVisitResult visitFile(
					Path file, BasicFileAttributes attrs)
						throws IOException {
				System.out.println(file);
				return FileVisitResult.CONTINUE;
			}
		});
	}

}

это абсолютно прозрачно для нашего кода, который один раз написан
и может быть переиспользован для разных файловых систем без изменений

ничто не мешает нам реализовать файловую систему, работающую с 
файлами внутри любого другого типа архива или вообще на удаленном
компьютере

Новый набор классов в пакете java.nio.file рекомендуется для
использования во всех новых java-программах, так как он по многим
параметрам лучше старого

## Потоки байт

Итак, мы нашли нужный файл и решили его прочитать, или наоборот
мы решили создать новый файл и записать в него какие-то данные

Давайте начнем знакомство с классами ввода-вывода в java 
с самого низкого уровня:

  * Ввод данных
  java.io.InputStream

  * Вывод данных
  java.io.OutputStream

InputStream представляет собой поток байтов, из которого можно 
читать по одному байту или блоками

симметричный ему класс OutputStream представляет собой поток
байтов, в который можно писать

оба класса -- абстрактные, создать их экземпляры нельзя, более
того на этом уровне иерархии наследования даже неизвестно,
с каким конкретно источником или получателем данных работают
эти streams

в программах всегда будут экземпляры каких-то конкретных подклассов,
работающих конкретно с файлом на диске или с участком памяти,
или с сетевым соединением и так далее, но каким бы ни был подкласс,
он всегда будет удовлетворять контракту, заданному базовыми
InputStream и OutputStream

Давайте посмотрим на основные методы, определенные в этих классах

package java.io;

public abstract class InputStream implements Closeable {

	public abstract int read() throws IOException;

	public int read(byte b[]) throws IOException {
		return read(b, 0, b.length);
	}

	public int read(byte b[], int off, int len) 
			throws IOException {
		// ...	
	}

	public long skip(long n) throws IOException {
		// ...
	}

	public void close() throws IOException {}

	// ...
}

метод read() -- он возвращает следующий байт из входного потока
и сдвигается дальше; возвращаемое значение int, но фактически из
потока считывается один байт, более широкий тип int нужен, чтобы
иметь возможность обозначить конец потока; когда конец достигнут,
метод вернет -1

если вернулась не -1, то фактический считанный байт можно получить,
приведя int к байту при помощи оператора приведения типа (byte),
то есть фактически взяв последние 8 бит int'а

при ошибках ввода-вывода все методы будут бросать исключение 
IOException

читать большие объемы данных побайтно -- не очень эффективно,
поэтому есть еще два метода, которые читают из потока блок байтов
и записывают их в переданный массив:

первый метод принимает только массив байт byte b[] и пытается считать
из потока количество байт, равное размеру массива

второй метод принимает еще 2 числа: индекс элемента массива,
начиная с которого этот массив нужно заполнять, и количество байт,
которое нужно считать из входного потока и записать в массив.

по возвращению из метода массив будет заполнен данными из входного
потока; возвращенное методом значение типа int означает количество
фактически считанных байт, оно может быть меньше, чем мы просили,
если поток совсем закончился или просто в данный момент в нем
недостаточно данных; на возвращенное значение обязательно надо
смотреть -- ровно столько байт было записано в переданный массив,
и ровно столько байт мы можем дальше использовать.

если вернулась -1 -- это означает конец потока

а еще есть метод skip, который просто пропускает заданное количество
байт, никуда их не сохраняя, он возвращает количество байт,
которое фактически удалось пропустить; это количество также
может быть меньше, чем мы просили.

второй класс OutputStream содержит аналогичные методы для записи
байтов по одному или блоками:

package java.io;

public abstract class OutputStream 
		implements Closeable, Flushable {

	public abstract void write(int b) throws IOException;

	public void write(byte b[]) throws IOException {
		write(b, 0, b.length);
	}

	public void write(byte b[], int off, int len)
			throws IOException {
		// ...
	}

	public void flush() throws IOException {
		// ...
	}

	public void close() throws IOException {
		// ...
	}

}

метод write выводит в поток один байт, младшие 8 бит int'а 
(переданного значения)

когда у нас большой объем данных для записи, то лучше воспользоваться
двумя другими методами write, принимающими массив

метод flush() -- сбрасывает возможные промежуточные буфера, где
конкретная реализация OutputStream может накапливать данные перед
передачей операционной системе

просто вызов метода write не гарантирует, что данные тут же будут
переданы операционной системе для обработки

в обоих классах есть метод close, закрывающий поток и освобождающий
связанные с ним ресурсы; закрытие включает в себя также сброс 
буферов, то есть вызывать flush перед close не требуется

рекомендуется использовать stream'ы в блоке try с ресурсами, чтобы
метод close гарантированно был вызван

для иллюстрации работы со stream'ами приведем часто используемую
идиому копирования данных из входного потока в выходной:

int totalBytesWritten = 0;
byte[] buf = new byte[1024];
int blockSize;
while((blockSize = inputStream.read(buf)) > 0) {
	outputStream.write(buf, 0, blockSize);
	totalBytesWritten += blockSize;
}

Теперь посмотрим на соответствующих классов-наследников, самая
насущная потребность -- это работа с файлами на диске, и она
покрывается классам FileInputStream и FileOutputStream

в конструктор они принимают либо строку с путем к файлу,
либо экземпляр класса java.io.File:

InputStream inputStream = 
			new FileInputStream(new File("in.txt"));

OutputStream outputStream = 
			new FileOutputStream(new File("out.txt"));

если у нас на руках есть экземпляр нового класса java.nio.file.Path,
то получить поток, соответствующий ему, можно при помощи методов
Files.newInputStream или Files.newOutputStream, конкретный класс
потока в данном случае мы не знаем, он зависит от того, на какую
реальную или виртуальную файловую систему указывает данный путь

Есть возможность прочитать ресурс из текущего classpath, с которым
запущена виртуальная машина; в зависимости от того, упакована 
программа в jar, это будет либо файл внутри архива, либо файл 
на диске, эта деталь от нас скрыта -- мы просто получаем InputStream,
соответствующий содержимому файла

try (InputStream inputStream =
		Main.class.getResourceAsStream("Main.class")) {

	int read = inputStream.read();
	while (read >= 0) {
		System.out.printf("%02x", read);
		read = inputStream.read();
	}

}

вот так, например, Main.class.getResourceAsStream("Main.class")
класс может прочитать свой собственный байт-код

stream'ы используются и для обмена данными по сети, надо только
сначала открыть сетевое соединение:

try (Socket socket = new Socket("ya.ru", 80)) {

	OutputStream outputStream = socket.getOutputStream();
	outputStream.write("GET / HTTP/1.0\r\n\r\n".getBytes());
	outputStream.flush();

	InputStream inputStream = socket.getInputStream();
	int read = inputStream.read();
	while (read >= 0) {
		System.out.print((char) read);
		read = inputStream.read();
	}

}

а затем получить из него OutputStream, в который можно что-то 
выводить и InputStream, из которого можно прочитать результат

иногда данные уже записаны в памяти виртуальной машины, и мы
хотим скормить их какому-то коду, принимающему InputStream;
для этого есть класс ByteArrayInputStream:

byte[] data = {1, 2, 3, 4, 5};
InputStream inputStream =
	new ByteArrayInputStream(data);

аналогично можно подсунуть коду, записывающему данные в OutputStream,
экземпляр класса ByteArrayOutputStream, а потом получить записанные
данные в виде массива байт:

ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
// ...
byte[] result = outputStream.toByteArray();

это удобно использовать для тестирования своего кода



методы read и write в классах InputStream и OutputStream -- 
универсальны, но слишком низкоуровневы, и поэтому не очень удобные;
чтобы записать в поток какие-то структурированные, типизированные
данные, например, строки, числа, объекты, нам придется реализовывать
все руками, чтобы сначала преобразовать это все в массив байт.

К счастью, разработчики Java это учли и придумали такую штуку:
один stream может быть завернут в другой -- внутренний stream 
занимается реальным вводом-выводом, а внешний -- его декорирует,
добавляет какую-то полезную функциональность; например, 
класс DataOutputStream оборачивает любой другой произвольный
OutputStream и добавляет к низкоуровневым методам write удобные
методы для записи всех примитивных типов в java, а также метод
writeUTF для записи строк:

package java.io;

public class DataOutputStream
	extends FilterOutputStream implements DataOutput {

	public DataOutputStream(OutputStream out) {
		// ...
	}

	public final void writeInt(int v) throws IOException {
		out.write((v >>> 24) & 0xFF);
		out.write((v >>> 16) & 0xFF);
		out.write((v >>> 8) & 0xFF);
		out.write((v >>> 0) & 0xFF);
		incCount(4);
	}

}

также есть класс DataInputStream, который оборачивает какой-то
другой произвольный InputStream и предоставляет методы для чтения
всех примитивных типов и строк:

package java.io;

public class DataInputStream 
	extends FilterInputStream implements DataInput {

	public DataInputStream(InputStream in) {
		// ...
	}
 
	public final int readInt() throws IOException {
		int ch1 = in.read();
		int ch2 = in.read();
		int ch3 = in.read();
		int ch4 = in.read();
		if ((ch1 | ch2 | ch3 | ch4) < 0)
			throw new EOFException();
		return ((ch1 << 24) + (ch2 << 16)
				+ (ch3 << 8) + (ch4 << 0));
	}

	// ...

}

связка DataInputStream и DataOutputStream позволяет удобно 
обмениваться примитивными значениями и строками между двумя
программами

и еще один интересный пример:

класс DeflaterOutputStream реализует сжатие записываемых данных 
по алгоритму Deflate на лету, а симметричный ему InflaterInputStream
по ходу чтения распаковывает данные, сжатые этим алгоритмом:

byte[] originalData = {1, 2, 3, 4, 5};

ByteArrayOutputStream os = new ByteArrayOutputStream();
try (OutputStream dos = new DefalterOutputStream(os)) {
	dos.write(originalData);
}

byte[] deflatedData = os.toByteArray();

try (InflaterInputStream iis = new InflaterInputStream(
			new ByteArrayInputStream(deflatedData))) {
	int read = iis.read();
	while (read >= 0) {
		System.out.printf("%02x", read);
		read = iis.read();
	}
}

обернув обычные stream'ы в Inflater и Deflater мы можем абсолютно
прозрачно для всего кода программы поддержать сжатие данных,
здесь уместно добавить, что закрытие внешнего stream'а закрывает
также и вложенные в него stream'ы, поэтому достаточно только одного
вызова close на самом верхнем внешнем stream'е.

## Потоки символов

Данные бывают не только бинарные, но и текстовые. Для работы с 
текстовыми данными нужны специализированные классы, более удобные,
чем низкоуровневые потоки байт InputStream и OutputStream. Такие
классы в стандартной библиотеки есть, их целое семейство:

начнем также с базового абстрактного уровня, на котором есть
два абстрактных класса

  * Ввод данных
  java.io.Reader

  * Вывод данных
  java.io.Writer

Класс Reader устроен абсолютно аналогично InputStream: у него
точно такие же методы read, только вместо массива байтов они
принимают массивы символов, а метод read без параметров
возвращает тот же int, но в этом int'е нужно уже смотреть не
на младший один байт, а на младшие два байта:

package java.io;

public abstract class Reader implements Readable, Closeable {

	public int read() throws IOException {
		// ...
	}

	public int read(char cbuf[]) throws IOException {
		return read(cbuf, 0, cbuf.length);
	}

	public abstract int read(char cbuf[], int off, int len)
			throws IOException;

	public long skip(long n) throws IOException {
		// ...
	}

	public abstract void close() throws IOException;

	// ...

}

Класс Writer аналогичен классу OutputStream только с заменой
байтов на char'ы, и еще у него есть пара перегруженных методов
write, принимающих строку

Откуда мы можем читать и куда можем писать символы? ну, во-первых,
можно превратить произвольный поток байтов в поток символов,
завернув его в InputStreamReader или в OutputStreamWriter:

Reader reader =
		new InputStreamReader(inputStream, "UTF-8");

Charset charset = StandardCharsets.UTF_8;
Writer writer = 
	new OutputStreamWriter(outputStream, charset);

при этом указывается кодировка, которая будет определять правила
превращения символов в байты и обратно:

кодировки бывают разные, например, широко используемая кодировка
UTF-8 кодирует каждый символ последовательностью от 1 до 6 байт
и может представить любой символ Unicode'а, более простая кодировка,
например, cp866 кодирует один символ одним байтом

передать кодировку можно либо в виде строки с именем, либо в виде
объекта типа Charset

экземпляр Charset можно получить либо по строковому имени кодировки
при помощи Charset.forName, либо взять готовый экземпляр из
стандартного набора, доступного в классе StandardCharsets; в этот
класс вынесен минимальный набор кодировок, которые все jvm обязаны
поддерживать, это такие кодировки как ASCII, UTF-8 и UTF-16,
через метод Charset.forName можно получить куда больше кодировок,
но тут уже никто не может гарантировать переносимость вашей 
программы

классы Charset и StandardCharsets живут в пакете java.nio.charset

если в конструктор InputStreamReader'а или OutputStreamWriter'а 
не передать кодировку, то будет использоваться системная кодировка
по умолчанию, узнать эту системную кодировку, получить ее в явном
виде можно из метода Charset.defaultCharset(), эта кодировка зависит
от текущей операционной системы и ее настроек, поэтому переносимая
программа не должна на нее полагаться и рекомендуется указывать
кодировку явно.

для чтения и записи текстовых файлов есть специализированные классы
FileReader и FileWriter,

Reader reader = new FileReader("in.txt");
Writer writer = new FileWriter("out.txt");

но почему то они не позволяют указать
явно кодировку, поэтому для работы с текстовыми файлами 
фиксированной, известной нам кодировки обычно используется следующая
конструкция:

Reader reader2 = new InputStreamReader(
		new FileInputStream("in.txt"), StandardCharsets.UTF_8);

Writer writer2 = new OutputStreamWriter(
		new FileOutputStream("out.txt"), StandardCharsets.UTF_8);


а еще есть классы CharArrayReader и StringReader для чтения символов
из массива или строки в памяти:

Reader reader = new CharArrayReader(
		new char[] {'a', 'b', 'c'});

Reader reader2 = new StringReader("Hello Man!");

и есть симметричные им CharArrayWriter и StringWriter для записи
в память, их удобно использовать для тестирования кода

как и в случае со stream'ами вяская удобная и полезная 
функциональность добавляется Reader'ом и Writer'ом при помощи 
вкладывания их друг в друга, 

например, класс BufferedReader
оборачивает произвольный Reader и добавляет к нему буфферизацию,
то есть даже если мы читаем из BufferedReader'а символы по одному,
он на самом деле запрашивает их у нижележащего Reader'а большими
блоками и сохраняет в своем внутреннем буффере

это должно положительно сказываться на производительности в
случае больших объемов данных; польза BufferedReader'а на этом
не заканчивается -- он добавляет удобный метод readLine, читающий
из потока целую строку до ближайшего символа конца строки,
сам символ конца строки не возвращается

если мы дочитали до конца и поток закончился, то получим из метода 
null


package java.io;

public class BufferedReader extends Reader {

	public BufferedReader(Reader in) {
		// ...
	}

	public String readLine() throws IOException {
		// ...
	}

	// ...

}

раньше, чтобы построчно прочитать и обработать файл, приходилось
городить что-то наподобие этого:

try (BufferedReader reader =
		new BufferedReader(
			new InputStreamReader(
					new FileInputStream("in.txt"),
						StandardCharsets.UTF_8))) {
	String line;
	while((line = reader.readLine()) != null) {
		// process line
	}
}

теперь с появлением пакета java.nio.file есть удобный метод
Files.newBufferedReader, который скрывает внутри себя эту 
многоэтажную конструкцию с вложенными stream'ами:

try (BufferedReader reader = Files.newBufferedReader(
		Paths.get("in.txt"), StandardCharsets.UTF_8)) {

	String line;
	while ((line = reader.readLine()) != null) {
		// process line
	}

}


если файл небольшой, можно сделать еще проще: 
метод Files.readAllLines вернет строки в виде списка, сразу все

List<String> lines = Files.readAllLines(
		Paths.get("in.txt"), StandardCharsets.UTF_8);

for (String line : lines) {
	// process line
}

симметричный классу BufferedReader класс BufferedWriter добавляет
аналогичную буфферизацию на запись, то есть копит большие куски
данных и сбрасывает их по мере накопления в оборачиваемый Writer,
а еще BufferedWriter добавляет метод newLine, выводящий в выходной
поток разделитель строк, используемый на данной платформе:

try (BufferedWriter writer = Files.newBufferedWriter(
			Paths.get("out.txt"), StandardCharsets.UTF_8)) {

	writer.write("Hello");
	writer.newLine();

}

Для небольших объемов данных можно воспользоваться удобным методом
Files.write, который принимает список строк и внутри себя делает
все необходимое для его записи в выходной текстовый файл:

List<String> lines = Arrays.asList("Hello", "world");
Files.write(Paths.get("out.txt"), lines,
				StandardCharsets.UTF_8);


классы Reader и Writer -- универсальны, но не слишком удобны для 
повседневного использования: отсутствует форматированный ввод-вывод

форматированный ввод-вывод значений разных типов реализован в java
как надстройка, следующий уровень над Reader'ом и Writer'ом

форматированный вывод обеспечивает класс PrintWriter, в нем есть
методы print и println, перегруженные для всех примитивных типов,
а также строк и объектов; PrintWriter конвертирует это все в строки
и спускает в нижележащий Writer для вывода, объекты преобразуются
в строки при помощи вызова метода toString()

package java.io;

public class PrintWriter extends Writer {

	public PrintWriter (Writer out) {
		// ...
	}

	public void print(int i) {
		// ...
	}

	public void println(Object obj) {
		// ...
	}

	public PrintWriter printf(String format, Object ... args) {
		// ...
	}

	public boolean checkError() {
		// ...
	}

}

PrintWriter не бросает IOException, вместо этого они молча
устанавливают внутренний флаг ошибки, который можно проверить
при помощи метода checkError

у класс PrintWriter есть класс-родственник -- PrintStream:

public class PrintStream extends FilterOutputStream
	implements Appendable, Closeable {

	public PrintStream(OutputStream out) {
		// ...
	}

	public void print(int i) {
		// ...
	}

	public void println(Object obj) {
		// ...
	}

	public PrintWriter printf(String format, Object ... args) {
		// ...
	}

	public boolean checkError() {
		// ...
	}

}

на вид он очень похож, так как предоставляет те же самые методы
print, println и printf и не бросает исключений, но он оборачивает
OutputStream, а не Writer, и сам является OutputStream'ом

внутри методов print он делает сразу два преобразования:
сначала из примитивных типов и объектов -- строку, а потом
сразу в байты, которые передаются дальше нижележащему output 
stream'у для вывода


java.io.StreamTokenizer умеет разбирать поток на слова и числа

StreamTokenizer streamTokenizer =
		new StreamTokenizer(
			new StringReader("Hello world"));


// java.util.StringTokenizer
StringTokenizer stringTokenizer =
		new StringTokenizer("Hello world");

говорят, что необчень удобные классы в использовании, поэтому сразу
рассмотрим их альтернативу -- это класс java.util.Scanner

он создается, например, на основе Reader'а, хотя есть и другие
конструкторы, и позволяет парсить в нем все примитивные типы
и строки

Reader reader = new StringReader(
			"abc|true|1,1e3|-42");

Scanner scanner = new Scanner(reader)
			.useDelimiter("\\|");
			.useLocale(Locale.forLanguageTag("ru"));

String token = scanner.next();
boolean bool = scanner.nextBoolean();
double dbl = scanner.nextDouble();
int integer = scanner.nextInt();

у Scanner'а есть некоторое количество настроек, влияющих на его
работу, например, можно указать шаблон разделителя, который будет
использоваться для нарезания входного потока на токены; по умолчанию
это пробельные символы, но можно задать свое, например, как у нас,
вертикальные палки


public class utf8_train {

	public static void main(String[] args) {
		String s = "Ы";
		byte[] bArr = s.getBytes(StandardCharsets.UTF_8);
		for(byte b : bArr) {
			System.out.printf("%02x ", b);
		}
		System.out.printf("\n");

	}
}


Реализуйте метод, который зачитает данные из InputStream и преобразует их в строку, используя заданную кодировку.

Пример

InputStream последовательно возвращает четыре байта: 48 49 50 51.

Метод, вызванный для такого InputStream и кодировки ASCII, должен 
вернуть строку "0123".

```java
public static String readAsString(InputStream inputStream, Charset charset) throws IOException {
    InputStreamReader reader = new InputStreamReader(inputStream, charset);
    final int bufferSize = 1024;
    final char[] buffer = new char[bufferSize];
    StringBuilder sb = new StringBuilder();
    for(;;) {
        int ret = reader.read(buffer, 0, buffer.length);
        if (ret < 0) {
            break;
        }
        sb.append(buffer, 0, ret);
    }
    return sb.toString();
}
```

Напишите программу, читающую текст из System.in и выводящую в 
System.out сумму всех встреченных в тексте вещественных чисел с 
точностью до шестого знака после запятой. Числом считается 
последовательность символов, отделенная от окружающего текста 
пробелами или переводами строк и успешно разбираемая методом 
Double.parseDouble.


Sample Input 1:
1 2 3
Sample Output 1:
6.000000
Sample Input 2:
a1 b2 c3
Sample Output 2:
0.000000
Sample Input 3:
-1e3
18 .111 11bbb
Sample Output 3:
-981.889000

```java
import java.util.Scanner;
import java.io.*;

public class Main {

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		double res = 0;	
		while(sc.hasNext() ) {
			if (sc.hasNextDouble()) {
				res += sc.nextDouble();	
			}
			else {
				sc.next();
			}
		}
		System.out.printf("%.6f\n", res);
	}
}
```

## Generics

Для решения проблемы copy-paste'а разработчики java пошли по пути
C++ и добавили в java 5 возможность параметризации классов,
интерфейсов и методов каким-то типом, то есть вместо конкретных
типов можно объявить и затем использовать некоторую переменную,
в качестве которой будет подставлен любой тип, удовлетворяющий
условиям

public static <T extends Comparable<T>> T minElement(T[] values) {
	
	if (values.length == 0) {
		return null;
	}

	T min = values[0];
	for (int i = 1; i < values.length; i++) {
		if (min.compareTo(values[i]) > 0) {
			min = values[i];
		}
	}
}

однако, несмотря на явную аналогию с template'ами С++, generic'и
в java не так мощны и имеют существенные ограничения: первое
ограничение generic'ов в java -- параметризация возможна только
с ссылочным типом, то есть значением параметра не может быть
примитивный тип или примитивное значение, что было возможно в C++

т.е. TreeNode<String> stringNode; OK
	 TreeNode<Integer> integerNode; OK
	 TreeNode<int[]> intArrayNode; OK
	 TreeNode<int> intNode; 	ERROR
	 TreeNode<10> tenNode; 		ERROR


давайте посмотрим на синтаксис, как объявляется параметризованный
класс: после имени класса идут угловые скобки с именами generic
параметров, если их несколько, то они будут перечислены через
запятую; при желании мы можем объявить ограничения на тип параметра,
использую выражение extends, а дальше имя класса или интерфейса,
можно потребовать даже чтобы параметр реализовывал несколько
интерфейсов, перечислив их через знак амперсанда &

package java.util;

public final class Optional<T> {
	
	private final T value;

	private Optional(T value) {
		this.value = Objects.requireNonNull(value);
	}

	public static <T> Optional<T> of(T value) {
		return new Optional<>(value);
	}

	public T get() {
		if (value == null) {
			throw new NoSuchElementException("No value present");
		}
		return value;
	}

	// ...
}

в теле класса этот generic параметр может использоваться практически
в любом месте, где обычное имя типа: можно объявить поле, или
возвращаемое значение метода, или параметр метода, или локальную
переменную.

generic параметр, заданный на уровне класса, используется для
параметризации экземпляров, поэтому не доступен в статических
полях и методах; статический, да и не статический метод можно
параметризовать отдельно от класса, объявив generic-параметры
в угловых скобках после модификаторов, но перед именем возвращаемого
типа:

public static <T> Optional<T> of(T value) {
	return new Optional<>(value);
}

в данном случае параметр тоже называется T, но это T -- совсем другое
, не то, что указано в заголовке класса

пустые скобки new Optional<>(value); называется diamond operator,
здесь можно было бы явно написать new Optional<T>, а можно этого
не делать, и тогда компилятор сам подставит сюда параметры,
взятые из типа переменной, куда мы присваиваем значение.

diamond operator работает только вместе с оператором new

Что происходит, когда мы в программе начинаем использовать тип
Optional<T>, параметризованный, например, String'ом (Optional<String>
) ? В C++ это означало бы, что компилятор пошел бы в декларацию
класса Optional и подставил бы на место всех использований параметра
T наш конкретный тип String, скомпилировал бы такую отдельную версию
класса Optional; в Java все несколько иначе: класс Optional всегда
будет один, с какими бы параметрами его не инстанцировали, компилятор
не создает специализированной версии класса, а создает единственную
максимально общую версию класса, и в байткоде получается следующий
класс, где вместо T везде подставлен тип Object:

package java.util;

public final class Optional {

	private final Object value;

	private Optional(Object value) {
		this.value = Objects.requireNonNull(value);
	}

	public static Optional of(Object value) {
		return new Optional(value);
	}

	public Object get() {
		if (value == null) {
			throw new NoSuchElementException("No value present");
		}
		return value;
	}

	// ...
}

из-за того, что класс -- один, компилятору приходится "колдовать"
в местах использования этого класса с различными параметризациями;
там, где переменная объявлена как Optional<String>, компилятор
разрешит вызвать метод orElse только со значением типа String

Optional<String> optional = Optional.of("foo");
String value1 = optional.orElse("bar");
String value2 = optional.get();

хотя фактически с точки зрения виртуальной машины этот метод
принимает любой Object

возвращаемый методом get значение, хотя с точки зрения виртуальной
машины является Object'ом, но компилятор добавляет здесь неявное
привидение к типу String

String value2 = (String) optional.get();

это привидение типа можно увидеть в байт-коде, его добавляет 
компилятор

Параметризованный класс можно использовать, не указывая значение
generic параметра, и тогда класс покажет свое истинное лицо:
он начинает принимать и отдавать Object

Optional optional = Optional.of("foo");

String value1 = (String) optional.orElse("bar");

String value2 = (String) optional.get();

на такое использование класса без указания generic параметра 
компилятор выдаст предупреждение, но все равно это скомпилирует,
просто он перестанет делать проверки и преобразования типов --
все это будет на руках программиста

Разработчики java сознательно пошли на это, когда добавляли поддержку
generic'ов в язык, чтобы миллионы строк кода, написанные к тому 
времени, продолжали успешно компилироваться и работать с новой
версией языка, когда многие классы стандартной библиотеки внезапно
стали параметризованными.

все это приводит ко второму серьзному ограничению generic:
внутри параметризованного класса или метода нельзя создавать 
экземпляр или массив T:

T obj = new T();

T[] arr = new T[5];

if (obj instanceof T) {...}

T a = (T) b;

также не работает проверка instanceof; все это просто компилятор
не скомпилирует, так как внутри класса про конкретное T, с которым
создали данный экземпляр, ничего не известно, а привидение типа к
T, хоть и скомпилируется, но на самом деле ничего не сделает,
то есть не проверит, что объект b действительно является 
экземпляром T

это позволяет, например, реализовать следующий хак по превращению
проверяемого исключения в непроверяемое:

public class except_hack {
	public static void main(String[] args) {
		throwAsUncheked(new IOException()); 
	}

	private static void throwAsUncheked(Exception e) {
		except_hack.<RuntimeException>genericThrow(e);
	}

	private static <T extends Throwable>
			void genericThrow(Exception e) throws T {
		throw (T) e;		
	}

}

дело в том, что исключения делятся на проверяемые и непроверяемые
только с точки зрения компилятора, а виртуальная машина их
не различает, для нее все исключения являются не проверяемыми,
то есть она прекрасно может бросить проверяемый Exception из
метода, где он не задекларирован.

Отдельно стоит обсудить поведение generic'а совместно с 
наследованием, вспомним, что у нас есть базовый класс 
java.lang.Number и его наследник java.lang.Integer; мы можем
спокойно присвоить объект типа Integer в переменную типа Number

Number number = new Integer(1); OK

или массив Integer в массив Number

Number[] numberArray = new Integer[10]; OK

однако с generic'ами ситуация другая: Optional<Integer> нельзя
присвоить в переменную типа Optional<Number> -- это не 
скомпилируется; с точки зрения компилятора эти типы не совместимы

Optional<Integer> optionalInt = Optional.of(1);

Optional<Number> optionalNumber = optionalInt; ERROR

это запрещено из следующих соображений: давайте представим, что 
в Optional есть метод set, заменяющий объект внутри контейнера

optionalNumber.set(new BigDecimal("3.14"));

тогда, присвоив Optional<Integer> в Optional<Number>, мы могли бы
следующим шагом заменить объект внутри optionalInt (optionalNumber) 
на какой-нибудь BigDecimal, и тем самым нарушив ограничения,
заданные при создании контейнера

кстати, в случае с массивами виртуальная машина защищает нас от
подобной ошибки:

если мы попытаемся положить в массив значение другого не совместимого
типа, например, BigDecimal

Number[] numberArray = new Integer[10];
numberArray[0] = new BigDecimal("3.14");

то виртуальная машина бросит исключение ArrayStoreException

можно использовать generic типы не просто с T, а с некоторым
выражением-маской относительно T

package java.util;

public final class Optional<T> {

	private final T value;

	public void ifPresent(Consumer<? super T> consumer) {
		if (value != null)
			consumer.accept(value);
	}

	public T orElseGet(Supplier<? extends T> other) {
		return value != null ? value : other.get();
	}

}

Consumer<? super T> consumer -- говорим, что принимаем Consumer,
принимающего объект любого супер-типа T

Supplier<? extends T> -- говорим, что принимаем Supplier любого
подтипа T

при этом сам тип T тоже считается своим супер-типом и своим подтипом

эврестическое правило здесь такое: если вы собираетесь получать 
объекты откуда-то, то используйте <? extends T>, а если отдавать
куда-то, то <? super T>


в тех случаях, когда нам все равно, чем параметризован generic,
можно просто написать <?>:

Optional<?> optional = Optional.of(1);

это означает, что принимается любое значение generic параметра,
при этом когда мы попробуем получить из такого optional значение
типа T, то оно будет возвращаться как Object, а методы, принимающие
параметры типа T, вызвать будет не возможно

Object value2 = optional.orElse(2);

когда компилятор не видит конкретное значение generic параметра T,
то он не может проконтролировать совместимость типов и откажется
это компилировать


Предположим, у нас есть параметризованный класс

public class Example<X> {
    ...
}

Что можно подставлять в качестве значения параметра X при 
использовании этого класса в программе?

Ответ:

  *  символ "?" или более сложное выражение с ключевыми словами 
  extends и super

  *  имя любого перечисления (например, DayOfWeek)
  * имя любого интерфейса (например, CharSequence)
  * имя любого класса (например, Object)
  * значение X можно не указывать, т.е. использовать класс Example 
  как обычный непараметризованный


Задача:

Реализуйте generic-класс Pair, похожий на Optional, но содержащий 
пару элементов разных типов и не запрещающий элементам принимать 
значение null.

Реализуйте методы getFirst(), getSecond(), equals() и hashCode(), а 
также статический фабричный метод of(). Конструктор должен быть 
закрытым (private).

С корректно реализованным классом Pair должен компилироваться и 
успешно работать следующий код:

```java
Pair<Integer, String> pair = Pair.of(1, "hello");
Integer i = pair.getFirst(); // 1
String s = pair.getSecond(); // "hello"

Pair<Integer, String> pair2 = Pair.of(1, "hello");
boolean mustBeTrue = pair.equals(pair2); // true!
boolean mustAlsoBeTrue = pair.hashCode() == pair2.hashCode(); // true!
```


Ответ:

class Pair<T1, T2> {
    private T1 obj1;
    private T2 obj2;
    
    private Pair(T1 obj1, T2 obj2) {
        this.obj1 = obj1;
        this.obj2 = obj2;
    }
    
    public static <T1, T2> Pair<T1, T2> of(T1 obj1, T2 obj2) {
        return new Pair<>(obj1, obj2);
    }
    public T1 getFirst() {
        return obj1;
    }
    
    public T2 getSecond() {
        return obj2;
    }
    
    public int hashCode() {
        return Objects.hash(obj1, obj2);
    }
    
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        
        if (!(obj instanceof Pair)) {
            return false;
        }
        
        Pair<?, ?> other = (Pair<?, ?>) obj;
        return Objects.equals(obj1, other.obj1) && Objects.equals(obj2, other.obj2);
    }
    
    
}

## Коллекции

Коллекциями в Java называют разнообразные контейнеры однотипных 
элементов

чем плохи и неудобны массивы ?

ну, например, фиксированном при создании размером: если вдруг
в процессе работы программы у нас образовалось еще несколько объектов
, которые надо добавить к имеющимся, то надо выделить новый массив
большего размера, скопировать туда элементы старого массива и после 
них дописать новые элементы:

int[] oldArray = ...;
int oldLength = oldArray.length;

int newLength = oldLength + 10;
int[] newArray =
		Arrays.copyOf(oldArray, newLength);

newArray[oldLength] = newElement1;
newArray[oldLength + 1] = newElement2;

этот код неэффективен и неудобен, особенно в структурах, динамически
меняющих свой размер

к счастью, стандартные коллекции прекрасно решают эту задачу, скрывая
все утомительные подробности внутри; кроме того у массивов нет
никакой защиты от изменения

final int[] array = new int[] {1, 2, 3};

array[0] = 10;
array[1] = 11;
array[2] = 12;

если массив доступен какому-то коду на чтение, то он точно так же
доступен и для записи: любому элементу можно присвоить новое значение

ключевое слово final не поможет, так как оно действует только на
ссылку на массив, а к элементам не относится

коллекции же могут разрешать чтение, но запрещать изменение своего
содержимого

Коллекции живут в пакете java.util, коллекции для многопоточных
программ в пакете java.util.concurrent

Базовый интерфейс коллекции java.util.Collection:

package java.util;

public interface Collection<E>
		extends Iterable<E> {

	int size();

	boolean isEmpty();

	boolean contains(Object o);

	boolean add(E e);

	boolean remove(Object o);

	void clear();

	// ...
}

он описывает самые общие действия, применимые к любой коллекции

методы add и remove возвращают true, если коллекция изменилась,
и false -- если нет

при вызове add она может не измениться, если такой элемент в ней уже
есть и коллекция следит за уникальностью элементов, а при вызове
remove может оказаться, что такого элемента нет, в этих
случаях будет возвращен false

методы contains, remove, а для некоторых типов коллекций еще и
метод add используют в своей работе метод equals для сравнения
переданного объекта с тем, что уже есть в коллекции, поэтому
для тех классов, экземпляры которых вы собираетесь хранить 
в коллекциях, важно обеспечить адекватную реализацию equals;
адекватность метода equals зависит от задачи -- где-то подойдет
унаследованная от Object реализация, а где-то нужно сравнение
содержимого

например, для класса ComplexNumber скорее всего придется определить
equals для сравнения содержимого

у коллекций есть метод iterator, унаследованный от интерфейса
java.util.Iterable и возвращающий экземпляр java.util.Iterator

Collection<Integer> collection = ...;

Iterator<Integer> it = collection.iterator();
while (it.hasNext()) {
	Integer element = it.next();
	System.out.println(element);
}

for (Integer element : collection) {
	System.out.println(element);
}

этот интерфейс позволяет единообразно обходить элементы любой
коллекции, не задумываясь об ее внутреннем устройстве, будь то
дерево, связный список или массив; у итератора есть 3 метода:
первый hasNext -- это проверка наличия следующего элемента,
второй next -- это получение того самого следующего элемента,
и третий метод remove -- удаляющий текущий элемент из коллекции

текущим считается тот элемент, который последним был возвращен из
next, что логично, так как чтобы определить, удалять нам элемент 
или нет, надо сначала на него посмотреть

перед вызовом next надо обязательно проверять наличие элемента
при помощи hasNext, так как при отсутствии следующего элемента
метод next бросит исключение java.util.NoSuchElementException

цикл for-each позволяет записать все то же самое короче, 

for (Integer element : collection) {
	System.out.println(element);
}

он поддерживает не только массивы, но и любые экземпляры 
java.util.Iterable, а по счастливому стечению обстоятельств интерфейс
java.util.Collection как раз наследуется от Iterable

второй способ записать обход коллекции более компактно -- это
воспользоваться методом forEach из того же интерфейса 
java.util.Iterable

Collection<Integer> collection = ...;
collection.forEach(System.out::println);

метод принимает в качестве параметра экземпляр 
java.util.function.Consumer<T> -- функциональный интерфейс с 
единственным методом accept(T); и в данном случае мы пользуемся
возможностью инстанцировать функциональный интерфейс при помощи
ссылки на метод

однако, если в процессе обхода надо удалять некоторые элементы,
то ни одна из сокращенных записей нам не подойдет -- придется
использовать iterator явно

попытка вызвать метод remove на самой коллекции в процессе обхода
приведет к исключению java.util.ConcurrentModificationException

Collection<Integer> collection = ...;

for (Integer number : collection) {
	if (number > 5) {
		collection.remove(number);
	}	
}

коллекции не любят, когда их в процессе обхода меняют не через 
итератор

первая разновидность коллекции -- это List:

package java.util;

public interface List<E> extends Collection<E> {

	E get(int index);

	E set(int index, E element);

	void add(int index, E element);

	E remove(int index);

	int indexOf(Object o);

	int lastIndexOf(Object o);

	List<E> subList(int fromIndex, int toIndex);

}

List предоставляет доступ к элементам по их индексам, как массив;
один и тот же элемент может встречаться в списке несколько раз
по разным индексам

методы indexOf и lastIndexOf ищут элемент в данном списке и 
возвращают его индекс, либо первый с начала, либо первый с конца,
и если элемент не найден, то они вернут -1

и, наконец, метод subList возвращает часть списка в виде отдельного
экземпляра List, но важно, что изменения одного списка будут видны
в другом, то есть это не копирование

метод subList позволяет организовывать более сложные операции,
которые не вынесены в интерфейс List в явном виде, например,
удаление элементов с индексами в диапазоне от 1 до 3:

List<String> words = ...;

words.subList(1, 3).clear();

или поиск элемента среди элементов с индексами в диапазоне
от 10 до 15

int indexOfFoo = 
	10 + words.subList(10, 15).indexOf("foo");

надо только не забыть отдельно обработать случай, когда возвращается
-1, признак того, что элемент не найден

метод equals у списка специфицирован таким образом, что он сравнивает
списки по содержимому, то есть списки равны, если они содержат одни
и те же элементы в одинаковом порядке

общеизвестные реализации интерфейса List:

List<String> list1 = new ArrayList<>();

List<Integer> list2 = new LinkedList<>();

первая -- это ArrayList, которая реализует List поверх массива,
дает максимально дешевый доступ к элементу по его индексу,
почти такой же дешевый, как в массиве; добавление или удаление
элементов уже не такое дешевое, так как может приводить к 
перевыделению массива или как минимум к сдвигу элементов в массиве

вторая реализация -- LinkedList, основана на двухсвязном списке,
позволяет эффективно добавлять и удалять элементы в начале или
конце списка, зато доступ по индексу дороже, так как чтобы получить
элемент по индексу n, требуется сделать n итераций по указателям
списка

при объявлении переменной лучше пользоваться максимально общим
интерфейсом, а конкретный класс указывать только в месте создания
экземпляра -- так можно будет в любой момент заменить реализацию
коллекции, исправив всего одно место в программе

это еще полезно, когда вы пишите библиотечные методы для 
использования другими программистами

## Queue

вторая разновидность коллекции -- это Queue 

package java.util;

public interface Queue<E>
		extends Collection<E> {

	boolean add(E e);
	boolean offer(E e);

	E remove();
	E poll();

	E element();
	E peek();
}

это стандартная структура данных, обеспечивающая порядок FIFO

методы add и offer добавляют элемент в хвост очереди, разница
между ними следующая: если очередь ограничена по размеру и уже
достигла этого максимального размера, то add кидает исключение,
а offer возвращает false

методы remove и poll извлекают первый элемент из головы очереди,
в случае, если очередь пуста, remove кидает исключение, а poll
вернет null.

методы element и peek позволяют посмотреть элемент в голове очереди,
не удаляя его; разница между ними точно такая же: element бросит
исключение, а peek вернет null

## Deque

наследник очереди -- интерфейс java.util.Deque

package java.util;

public interface Deque<E> extends Queue<E> {

	void addFirst(E e);
	void addLast(E e);

	boolean offerFirst(E e);
	boolean offerLast(E e);

	E removeFirst();
	E removeLast();

	// ...
} 

он отличается от очереди тем, что можно добавлять и удалять элементы
как в хвосте, так и в голове, количество методов, соответственно,
удваивается по сравнению с очередью

реализаций интерфейса Deque -- две:

Deque<Object> deque1 = ArrayDeque<>();

дек поверх массива

а во-вторых, это LinkedList:

Deque<Integer> deque2 = new LinkedList<>();

deque2.offerLast(1);
deque2.offerLast(2);
deque2.offerLast(3);

Integer element;
while ((element = deque2.pollFirst()) != null) {
	System.out.println(element);
}

то есть класс LinkedList реализует сразу несколько интерфейсов:
он является одновременно и списком, и деком

## Set

третья разновидность коллекции -- это Set

package java.util;

public interface Set<E> 
		extends Collection<E> {

	// ...

}

эта коллекция обеспечивает уникальность содержащихся в ней элементов,
то есть Set не может содержать двух элементов, равных друг другу;
при попытке добавить дубликат методом add множество изменено не будет
-- как раз в этом случае метод вернет false

Интерфейс Set не добавляет новых методов относительно интерфейса
Collection, он только уточняет семантику существующих в родительском
интерфейсе методов, пэтому если открыть объявление интерфейса Set
в стандартной библиотеке, то в нем увидите все те же методы, что
и в Collection, но с другим javadoc'ом

например, метод equals определен так, что он будет сравнивать два 
множества по содержимому

реализаций интерфейса Set несколько:

первая из них -- HashSet -- реализация множества на основе 
хэш-таблицы, важную роль тут играет метод hashCode, HashSet
использует hashCode объекта для определения ячейки хэш-таблицы,
куда нужно положить этот объект, а метод equals затем используется
для сравнения с элементами, уже лежащими в этой ячейке хэш-таблицы

очень важно, чтобы реализации hashCode и equals были согласованными,
то есть если a.equals(b), то a.hashCode() == b.hashCode()

если это соотношение нарушается, то HashSet будет работать с 
элементами неправильно; например, вы будете добавлять элементы в
HashSet, а потом их не находить, или добавлять один и тот же
с точки зрения equals() элемент, а он по факту добавится много раз
в разные ячейки хэш-таблицы

Set<ComplexNumber> numbers = new HashSet<>();

numbers.add(new ComplexNumber(3, 3));
numbers.remove(new ComplexNumber(3, 3));

и еще важный момент: объект не должен меняться, пока он лежит в 
HashSet'е -- точнее не должны меняться его поля, влияющие на
вычисления equals и hashCode, в крайнем случае, можно
удалить объект из HashSet'а, поменять его и добавить обратно,
чтобы он добавился уже с новым hashCode'ом и попал в новую
ячейку хэш-таблицы

Set<String> words1 = new HashSet<>();
words1.add(...);

порядок обхода HashSet'а итератором обусловлен хэш-кодами 
элементов, точнее, раскладкой объектов по хэш-таблице, которая
определяется хэш-кодами

если мы попробуем при помощи итератора обойти все элементы HashSet'а
, то порядок обхода для стороннего наблюдателя будет казаться
случайным:

for (String s : words) { ... }

если порядок элементов важен, то предлагается использовать другую
реализацию Set -- LinkedHashSet

Set<String> words2 = new LinkedHashSet<>();
words2.add(...);

он отличается тем, что связывает все элементы в список в порядке
их добавления, что позволяет итератору ходить и возвращать элементы
в том порядке, в котором они были добавлены в Set

## SortedSet

от интерфейса Set наследуется интерфейс SortedSet -- упорядоченное
множество; благодаря упорядоченности, он обеспечивает обход элементов
итератором в порядке возрастания элементов, а также поддерживает
некоторые дополнительные операции: 
например, headSet возвращает подмножество элементов меньших, чем 
переданный параметр -- и это не копия, а множество, которое 
изменяется с основным

и аналогично есть методы tailSet, subSet, а также наименьший (first)
и наибольший (last) элементы

package java.util;

public interface SortedSet<E> extends Set<E> {

	SortedSet<E> subSet(
			E fromElement, E toElement);

	SortedSet<E> headSet(E toElement);

	SortedSet<E> tailSet(E fromElement);

	E first();

	E last();

}

реализация интерфейса SortedSet -- это класс TreeSet, внутри него --
самобалансирующееся двоичное дерево поиска, а именно красно-черное
дерево

SortedSet<String> words = new TreeSet<>();

words.add("aaa");
words.add("bbb");
words.add("ccc");

words.headSet("bbb").clear();

естественно, что TreeSet должен уметь сравнивать элементы друг
с другом, для этого элементы либо должны реализовывать интерфейс
java.lang.Comparable<T> с методом compareTo(T), либо в конструктор
TreeSet'а должен передаваться экземпляр java.util.Comparator<T>
с методом compare(T, T), принимающим два параметра, то есть
мы можем сравнивать объекты, которые сами не умеют сравниваться
друг с другом

поучительный пример использования коллекций -- это удаление
дубликатов из списка:

List<String> list = new ArratList<>();
list.add("aaa");
list.add("aaa");
list.add("bbb");
list.add("aaa");

Set<String> set =
		new LinkedHashSet<>(list);

List<String> listWithoutDups =
		new ArrayList<>(set);

здесь мы пользуемся тем, что по соглашению у каждого класса коллекции
есть конструктор, принимающий в качестве параметра другую коллекцию;
при этом все элементы исходнрой коллекции копируются в новую,
поэтому мы просто создаем новый LinkedHashSet от нашего исходного
списка, который удалит дубликаты и при этом сохранит порядок
следования элементов, а потом создаем обратно список из множества.

## Map

четвертый вид коллекции -- это Map, отображение или ассоциативный
массив

package java.util;

public interface Map<K, V> {

	int size();
	boolean isEmpty();

	boolean containsKey(Object key);
	boolean containsValue(Object value);

	V get(Object key);
	V put(K key, V value);

	V remove(Object key);
	void clear();

	Set<K> keySet();
	Collection<V> values();
	Set<Map.Entry<K, V>> entrySet();

}

строго говоря, он не наследует интерфейс Collection, но идеологически
тоже относится к коллекциям

в отличие от массивов, где элементы индексируются числами, Map
позволяет индексировать элементы произвольными объектами, например,
строками, элементами перечисления, комплексными числами и так далее

метод containsKey проверяет, есть ли сейчас в Map такой ключ
метод containsValue, проверяющий, есть ли такое значение в Map
метод get, получающий значение по ключу
метод put, сохраняющий значение по ключу
метод remove, удаляющий пару ключ-значение с заданным ключом
и метод clear, очищающий map

метод put и remove возвращают значение, которое было по данному
ключу перед выполнением запрошенной операции; 

поскольку интерфейс Map не расширяет Collection и не расширяет 
Iterable, то встает вопрос, как его обходить

тут все зависит от ваших потребностей: если нужны только ключи,
то пользуйтесь методом keySet, который вернет Set, то есть множество
ключей; это множество, потому что дубликаты ключей в Map'е 
не допускаются

если вам нужны только значения, то пользуйтесь методом values,
который вернет вам коллекцию всех значений; это коллекция, а
не множество, потому что в общем случае про уникальность значений
нам ничего неизвестно

если при обходе вам одновременно требуется и ключ, и значение, то
пользуйтесь методом entrySet, который вернет вам множество из
Map.Entry, где Map.Entry -- простой объект, содержащий пару
ключ-значение

Map<A, B> map = new HashMap<>();

for (A key : map.keySet()) { ... }

for (B value : map.values()) { ... }

for (Map.Entry<A, B> entry : map.entrySet()) {
	System.out.printf("%s => %s\n",
			entry.getKey(), entry.getValue());
}

map.forEach((k, v) ->
		System.out.printf("%s => %s\n", k, v));

метод forEach принимает экземпляр java.util.function.BiConsumer<T, U>
-- это функциональный интерфейс с методом accept(T, U) с двумя 
параметрами

и мы передаем в качестве BiConsumer'а в данном примере 
лямбда-выражение

что касается реализации интерфейса Map:

есть HashMap, есть LinkedHashMap и есть TreeMap: их устройство
и отличие друг от друга абсолютно аналогично соответствующим
реализациям интерфейса Set

в стандартной библиотеке есть еще несколько классов-коллекций,
которые появились еще в Java 1.0 и в настоящий момент 
не рекомендуются к использованию, они оставлены лишь для обратной
совместимости, а их функционал полностью покрывается современными 
коллекциями, которые мы рассмотрели:

  * java.util.Vector
  * java.util.Stack
  * java.util.Dictionary
  * java.util.Hashtable


в работе с коллекциями иногда помогает утилитный класс 
java.util.Collections, в котором есть методы, например, shuffle для
перетасовывания списка или sort для сортировки списка и многие
другие:

Collections.shuffle(list);

Collections.sort(list);

в классе java.util.Collections есть также семейство методов с 
именами, начинающимися на unmodifiable; в частности, unmodifiableSet,
unmodifiableList, unmodifiableMap и так далее; 

Set<String> set =
	Collections.unmodifiableSet(originalSet);

set.remove("abc");
// throws java.lang.UnsupportedOperationException

эти методы возвращают объект-обертку, реализующую тот же интерфейс, 
что и переданный параметр, и предоставляющие доступ на чтение к 
элементам исходной коллекции, но при этом любая попытка изменить
содержимое коллекции через этот объект-обертку приведет к выбросу
UnsupportedOperationException, то есть мы можем при передаче 
коллекции в какой-то метод защититься от ее случайного там изменения

переодически приходится конвертировать коллекции в классический
массив:

List<Integer> list = ...;

Object[] array1 = list.toArray();

Integer[] array2 =
	list.toArray(new Integer[list.size()]);

для этого в интерфейсе Collection есть метод toArray, который
возвращает содержимое коллекции в виде массива Object[]
это связано с ограничениями generic'ов в java -- внутри 
параметризованного класса нельзя создавать экземпляры или массивы
типа указанного в качестве параметра generic'а

если нам хочется получить массив того типа, элементы которого
действительно лежат в коллекции, то надо воспользоваться
другим перегруженным вариантом метода toArray, который принимает 
массив правильного типа; если массив подходящего размера, то 
метод toArray сложит все элементы в этот переданный массив и
его же и вернет, если переданный массив не того размера, который
нужно, то метод toArray внутри себя перевыделит массив правильного
размера и вернет уже новый массив.

выполнить обратную конвертацию из массива в коллекцию тоже не трудно:
можно, например, превратить массив в список при помощи метода
Arrays.asList, а потом передать результат в конструктор любого
другого класса коллекции:

String[] array = {"A", "B", "C"};

Set<String> set1 =
	new HashSet<>(Arrays.asList(array));

или можно пойти другим путем и создать сначала пустую коллекцию,
а потом при помощи утилитного метода Collections.addAll добавить
туда все элементы из массива

Set<String> set2 = new HashSet<>();
Collections.addAll(set2, array);


Чем коллекции отличаются от массивов:

  * Коллекции можно сравнивать по содержимому обычным методом 
  equals(), а для сравнения массивов используется внешний утилитный 
  метод Arrays.equals().

  * Коллекции могут содержать только объекты, а массивы могут 
  содержать и примитивы.

  * Коллекции могут динамически менять размер, а размер массива 
  фиксируется при создании.

  * Массивы встроены в язык, а коллекции — обычные классы стандартной
  библиотеки.

Предположим, у нас есть две переменных:

Collection<?> collection = ...;
Object object = ...;

Какие операции над collection допустимы:

  *  collection.remove(object) // OK
  * collection.add(object) // Error
  *  collection.clear() // OK
  * collection.toArray() // OK
  * collection.iterator() // OK
  * collection.contains(object) // OK
  * collection.size() // OK
  * collection.addAll(Arrays.asList(object)) // Error

Почему так?
Вопросительный знак говорит компилятору: коллекция чем-то 
параметризована, но в данном месте кода мы не знаем, чем именно. 
Чтобы не дать нам случайно нарушить параметризацию коллекции, т.е. 
добавить в нее объект неправильного класса, компилятор не разрешает 
ничего добавлять.

<?> эквивалентно <? extends Object>

Как должны быть связаны между собой реализации equals() и hashCode() 
у класса, чтобы экземпляры этого класса можно было спокойно хранить 
в HashSet?

Ответ: если a.equals(b), то a.hashCode() == b.hashCode()

Задача:

Реализуйте метод, вычисляющий симметрическую разность двух множеств.

Метод должен возвращать результат в виде нового множества. Изменять 
переданные в него множества не допускается.

Пример

Симметрическая разность множеств {1, 2, 3} и {0, 1, 2} равна {0, 3}.

Решение:

```java
public static <T> Set<T> symmetricDifference(Set<? extends T> set1, Set<? extends T> set2) {
    Set<T> res = new HashSet<T>(set1);
    res.addAll(set2);
    
    Set<T> diff1 = new HashSet<T>(res);
    for (T item : set1) {
        if (diff1.contains(item)) {
            diff1.remove(item);
        }
    }

    Set<T> diff2 = new HashSet<T>(res);
    for (T item : set2) {
        if (diff2.contains(item)) {
            diff2.remove(item);
        }
    }
    
   diff1.addAll(diff2);
	return diff1;
}
```

Задача:

Напишите программу, которая прочитает из System.in 
последовательность целых чисел, разделенных пробелами, затем удалит 
из них все числа, стоящие на четных позициях, и затем выведет 
получившуюся последовательность в обратном порядке в System.out.

Все числа влезают в int. Позиции чисел в последовательности 
нумеруются с нуля.


Sample Input:
1 2 3 4 5 6 7

Sample Output:
6 4 2

```java
import java.util.Scanner;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        List<Integer> arr = new ArrayList<>();
        int i = 0;
        while (sc.hasNext() && sc.hasNextInt()) {
            int next = sc.nextInt();
            if ((i % 2) == 1)
                arr.add(next);
            i++;
        }
        
        ListIterator<Integer> iter = arr.listIterator(arr.size());
        while(iter.hasPrevious()) {
            System.out.printf("%d ", iter.previous());
        }
        System.out.printf("\n");
    }
}
```

## Функциональные интерфейсы

package java.util;

@FunctionalInterface
public interface Comparator<T> {
	
	int compare(T o1, T o2);

	// any number of default or static methods

}

Напомним, что интерфейс называется функциональным, если в нем ровно
один абсрактный метод, подчеркнуть это и дополнительно проверить 
на стадии компиляции можно при помощи аннотации @FunctionalInterface

default и статические методы при этом не в счет -- их в 
функциональном интерфейсе может быть сколько угодно, как и 
статических полей

зачем в язык были добавлены функциональные интерфейсы ? дело в том,
что в Java нет указателей на функцию, как в C или C++, поэтому
когда в java требуется передать в метод какой-то участок программной
логики, то метод обявляется как принимающий экземпляр какого-то
класса или интерфейса, а в месте вызова этого метода такой
экземпляр нужно как-то создать, зачастую обновив анонимный класс
с подходящей реализацией метода

например, условием для фильтрации файлов, возвращаемых методом
listFiles до java 7 приходилось записывать в следующем виде:

File directory = ...;

File[] javaSourceFiles = directory.listFiles(
	new FileFilter() {
		@Override
		public boolean accept(File file) {
			return file.getName().endsWith(".java");
		}
	});

содержащая часть логики фильтрации -- это одно выражение:
file.getName().endsWith(".java"), а вск остальное -- технические
детали

именно благодаря функциональным интерфейсам стало возможно избавиться
от использования анонимных классов и использовать компактные 
лямбда-выражения и ссылки на методы

в java 8 появилось целое семейство, целый пакет функциональных
интерфейсов самого общего вида на самые разные случаи жизни; когда
вы понимаете, что нужно передавать в метод кусок программной логики,
то вместо того, чтобы придумывать свой функциональный интерфейс,
посмотрите сначала на стандартные, очень вероятно, что подходящий
вам интерфейс там найдется, 
и другие программисты скажут вам спасибо,
поскольку вы будет говорить с ними на одном стандартном общепринятом
языке

стандартные функциональные интерфейсы живут в пакете 
java.util.function, их более 40, но они четко делятся на 5 семейств:

первое семейство -- это Consumer'ы или потребители, это те, которые
принимают какое-то значение, но ничего не возвращают взамен

package java.util.function;

@FunctionInterface
public interface Consumer<T> {

	void accept(T t);

}

этот consumer -- это generic, он параметризован типом объекта,
который он будет принимать

а есть еще отдельные интерфейсы IntConsumer, LongConsumer, 
DoubleConsumer, принимающие значения соответствующих примитивных 
типов, они существуют потому, что generic'и в java не могут 
параметризоваться примитивами, так что разработчикам стандартной
библиотеки пришлось здесь пойти на копи-паст

а еще бывают консьюмеры, принимающие два параметра, один из них --
это интерфейс BiConsumer<T, U> с двумя generic параметрами,
и, соответственно, его метод accept принимает два параметра указанных
типов и ничего не возвращает:

package java.util.function;

@FunctionalInterface
public interface BiConsumer<T, U> {

	void accept(T t, U u);

}

второе семейство -- это Supplier'ы, поставщики

package java.util.function;

@FunctionalInterface
public interface Supplier<T> {

	T get();

}

они не принимают ничего в качестве параметров, а просто возвращают
какое-то значение

это generic supplier, а есть еще отдельно BooleanSupplier,
IntSupplier, LongSupplier и DoubleSupplier

третье семейство -- это Predicate, предикаты

package java.util.function;

@FunctionalInterface
public interface Predicate<T> {

	boolean test(T t);

}

их функциональный метод принимает значение какого-то типа,
а наружу отдает boolean 

есть специализированные предикаты для IntPredicate, LongPredicate
и DoublePredicate, а также есть разновидность предиката, принимающего
сразу два параметра -- BiPredicate

четвертое семейство -- это Function, функция 

package java.util.function;

@FunctionalInterface
public interface Function<T, R> {

	R apply(T t);

}

функция принимает аргумент и возвращает значение какого-то типа,
в общем случае эти типы разные

бывают функции, принимающие 2 параметра -- это интерфейс BiFunction,
а также есть масса специализаций функции, где на месте одного или
обоих параметров стоят примитивы, например, DoubleFunction -- 
это функция, принимающая Double и возвращающая объект: double -> T
или LongToIntFunction: long -> int ; 
или ToIntFunction: T -> int

и таких специализаций еще много

а пятое семейство -- это операторы, оператор -- это частный случай
функции, когда на входе и на выходе значения одного и того же типа,

унарный оператор UnaryOperator принимает один параметр:

package java.util.function;

@FunctionalInterface
public interface UnaryOperator<T>
		extends Function<T, T> {

	// apply is inherited from Function
}

а BinaryOperator -- два параметра,
также заведеные унарные и бинарные операторы над примитивными типами
Int, Long и Double

эти функциональные интерфейсы не покрывают, конечно, все возможные 
потребности, которые могут возникнуть в жизни; в тех случаях, когда
подходящего интерфейса в стандартной библиотеке нет, например,
функция от трех параметров, то придется такой интерфейс написать
самостоятельно, но вся стандартная библиотека обходится этими
перечисленными стандартными функциональными интерфейсами


функциональные интерфейсы можно инстанцировать 3-мя способами:

во-первых, можно честно завести именованный или анонимный класс,
реализующий интерфейс:

class IntSquare implements IntUnaryOperator {

	@Override
	public int applyAsInt(int operand) {
		return operand * operand;
	}

}

но это громоздко, и если данный класс не будет переиспользоваться,
то совершенно излишне

во-вторых, можно использовать лямбда выражения:

IntUnaryOperator square = x -> {
	return x * x;
};

IntConsumer print = x -> System.out.print(x);

IntUnaryOperator cube = x -> x * x * x;

компилятор знает ожидаемый интерфейс, и поэтому не требует от вас
повторять имя этого интерфейса, а также имя метода, типы параметров
и тип возвращаемого значения справа от знака равенства:

вы просто объявляете имена параметров и тело метода; если тело
метода состоит из единственного выражения, и это не return, то
фигурные скобки вокруг метода можно опустить.

а если это был return, то с ключевыми скобками также убираем и
ключевое слово return

интересный вопрос: к каким переменным и как можно обращаться
в теле лямбда-выражения?

очевидно, что можно обращаться к параметрам лямбда-выражения, 
а также свободно объявлять и свободно использовать внутри тела
лямбда-выражения 

менее очевидно то, что можно обращаться к полям того класса,
внутри которого объявлена лямбда, причем их можно как читать,
так и писать:

public class Demo {

	private int counter;

	public void foo() {
		IntUnaryOperator square =
			x -> x * x;
		
		IntSupplier sequence = 
			() -> counter++;

		int bonus = 10;
		IntUnaryOperator bonusAdder =
			(x) -> x + bonus;
	}

}

и наконец, можно обращаться к переменным, объявленным внутри того
метода, где создано лямбда-выражение, но здесь есть ограничение:
переменные должны быть эффективно финальными, то есть значения
им должно быть присвоено ровно один раз до создания лямбды, после
чего оно уже меняться не может

это то же самое, если бы мы написали ключевое слово final:

		final int bonus = 10;
		IntUnaryOperator bonusAdder =
			(x) -> x + bonus;

и его можно написать, но компилятор этого не требует

отсюда, в частности, следует, что из лямбда-выражения нельзя
присваивать новые значения переменным содержащего его метода

для обхода этого ограничения иногда используют трюк с массивом
единичной длины:

int[] counter = new int[] {0};

IntSupplier sequence = () -> counter[0]++;

ссылка на массив является эффективно финальной, однако на содержимое
массива это ограничение не распространяется и его можно обновлять

и в-третьих, функциональный интерфейс можно инстанцировать при
помощи ссылки на метод:

ToIntFunction<String> intParser =
		Integer::parseInt;

Consumer<Object> printer =
		System.out::println;

Function<Object, String> objectToString =
		Object::toString;

IntFunction<String[]> arrayAllocator =
		String[]::new;

это самый простой на вид способ, но у него есть несколько ньюансов:
мы можем ссылаться на статический метод, указывая имя класса,
два двоеточия, имя статического метода; 

ToIntFunction<String> intParser =
		Integer::parseInt;


или мы можем ссылаться на нестатический метод, указывая конкретный 
объект, два двоеточия, имя нестатического метода:

Consumer<Object> printer =
		System.out::println;

еще один способ сослаться на нестатический метод -- это указать
имя класса, два двоеточия, имя нестатического метода, но тогда
первый передаваемый в месте вызова функционального интерфейса
параметр будет тем самым объектом, на котором данный нестатический
метод будет вызван:

Function<Object, String> objectToString =
		Object::toString;

еще можно ссылаться на конструктор -- тогда пишут имя класса,
два двоеточия и ключевое слово new:

IntFunction<String[]> arrayAllocator =
		String[]::new;


у стандартных функциональных интерфейсов кроме главного абстрактного
метода есть еще интересные статические и дефолтные методы, 
позволяющие делать разные полезные вещи:

например, если у нас есть некоторый предикат

IntPredicate isOdd = x -> x % 2 != 0;

то обратный ему можно получить при помощи метода negate:

IntPredicate isEven = isOdd.negate();

или если у нас есть два предиката, то мы можем построить их
конъюнкцию при помощи метода and:

IntPredicate p1 = ..., p2 = ...;

IntPredicate p3 = p1.and(p2);

если у нас есть два Consumer'а то мы можем их скомбинировать
в новый третий консьюмер, который вызовет сначала первое действие,
а затем второе:

Consumer<Object> printer =
		System.out::println;

List<Object> objects = new ArrayList<>();
Consumer<Object> collector = objects::add;

Consumer<Object> combinedConsumer =
		printer.andThen(collector);

то есть в данном случае сначала напечает объект в консоль, а потом
добавит в список

похожим образом можно строить композиции функций при помощи
методов andThen и compose, разница между этими методами в порядке
применения: метод andThen сначала применит первую функцию,
а затем вторую, а compose -- наоборот.

DoubleUnaryOperator square = x -> x * x;
DoubleUnaryOperator sin = Math::sin;

DoubleUnaryOperator complexFunction1 =
		sin.andThen(square); // (sin(x)) ^ 2

DoubleUnaryOperator complexFunction2 =
		sin.compose(square); // sin(x^2)


Каким образом можно получить экземпляр функционального интерфейса?

  * использовать ссылку на статический метод
  * использовать ссылку на конструктор
  * объявить анонимный класс, реализующий интерфейс, и создать 
  экземпляр этого класса
  * использовать лямбда-выражение
  * использовать ссылку на нестатический метод
  * объявить именованный класс, реализующий интерфейс, и создать 
  экземпляр этого класса

## Stream API

фишка Java 8
Stream -- это последовательность элементов, потенциально бесконечная
с возможностью применять к ней простые или сложные многоэтапные
преобразования; причем если обычно такие преобразования мы привыкли
записывать при помощи циклов и условных операторов, то Stream
позволяет это делать без единого цикла и условного оператора, то 
есть программа будет иметь простую линейную структуру

итак, Stream -- это generic интерфейс в пакете java.util.stream,
параметризованный типом элементов, из которых он состоит:

package java.util.stream;

public interface Stream<T>
		extends BaseStream<T, Stream<T>> {

	// MANY methods

}

рядом с ним лежат IntStream, LongStream и DoubleStream -- его
братья-близнецы, предназначенные для соответствующих примитивных
типов

если stream представляет собой последовательность элементов, то
чем он, например, отличается от итератора ? 

итератор -- это очень простой объект, умеющий только выдавать 
элементы по одному, а у stream'а -- огромное количество методов,
он представляет собой не только средство обхода элементов,
а средство описания алгоритма обработки и преобразования
последовательностей элементов

если сравнивать stream'ы с коллекциями, то коллекции предполагают
хранение всего набора элементов и, соответственно, конечны,
а stream потенциально может быть бесконечным; 

коллекции часто предоставляют индивидуальный доступ к своим элементам
, например, по индексу или по ключу, а stream такого не позволяет

коллекции можно менять: добавлять или удалять элементы, в том числе
через итератор, а применение трансформации к stream'у никак не влияет
на тот источник, из которого элементы берутся

чтобы говорить более предметно, давайте рассмотрим небольшой пример:

int sum = IntStream.iterate(1, n -> n + 1)
		.filter(n -> n % 5 == 0 && n % 2 != 0)
		.limit(10)
		.map(n -> n * n)
		.sum();

метод iterate в классе IntStream принимает число -- это первый
элемент последовательности, и вторым аргументом -- функцию, которая
вычисляет следующий элемент последовательности по предыдущему,
возвращается Stream

IntStream представляет собой бесконечную последовательность целых
чисел, начиная с 1, но вычисляться она еще не начала, потому
что Stream'ы ленивы и ничего не делают, пока их явно об этом 
не попросят

далее каждый следующий метод в цепочке добавляет какое-то 
преобразование и возвращает преобразованный Stream

последняя операция (sum) является спусковым механизмом для того,
чтобы он начал выполнять все те действия, которые мы ему передали
на предыдущих шагах

использования Stream'а всегда состоит из трех частей:
первое -- это получение Stream'а, откуда будут браться элементы
последовательности, есть много разных способов получить Stream;
вторая часть -- это 0 или более промежуточных операций преобразования
, Stream их просто запоминает, но пока не выполняет

и третья часть -- это единственная терминальная операция, запускающая
весь процесс вычисления, и которая, собственно, должна стать его
полезным результатом

и есть еще опциональный шаг -- это его закрытие при помощи метода
close, однако вызов этого метода по окончании работы со stream'ом
обязателен только в том случае, когда Stream выделял какие-то
системные ресурсы

в данном примере, очевидно, никакие ресурсы не выделялись

а вот если stream связан с содержимым файла или директории на
диске, то закрыть его надо, чтобы избежать утечек ресурсов

благодаря тому, что Stream реализует интерфейс Autocloseable,
его можно использовать в блоке try-with-resources

разберемся подробнее со всеми этапами работы со stream'ом:

первый этап -- это порождение stream'а

во-первых, его можно получить из любой коллекции при помощи
метода stream

Set<String> vocabulary = ...;
Stream<String> stream1 = vocabulary.stream();

или stream можно получить из BufferedReader'а при помощи метода
lines, который вернет поток строчек из данного потока символов:

BufferedReader reader = ...;
Stream<String> stream2 = reader.lines();

или можно получить stream из директории на диске при помощи
методов list и walk:

Path path = ...;
Stream<Path> stream3 = Files.list(path);
Stream<Path> stream4 = Files.walk(path);

метод list вернет содержимое директории на один уровень, а метод
walk рекурсивно обойдет и поддиректории тоже

это как раз примеры тех stream'ов, которые нужно закрывать и удобно
использовать в блоке try с ресурсами

и еще один пример: stream можно получить из строчки при помощи
вызова метода chars

IntStream chars = "hello".chars();

это stream будет содержать символы строки, но поскольку отдельного
CharStream в стандартной библиотеке -- нет, то мы получим IntStream


Stream'ы можно порождать динамически:

например, генерировать при помощи некоторого Supplier'а

DoubleStream randomNumbers = 
	DoubleStream.generate(Math::random);

Supplier -- интерфейс с единственным методом get(), и этот метод
get должен последовательно один за другим возвращать элементы
последовательности

IntStream integers =
	IntStream.iterate(0, n -> n + 1);

IntStream smallIntegers =
	IntStream.range(0, 100);

IntStream smallIntegers2 = 
	IntStream.rangeClosed(0, 100);

метод range  возвращает stream, состоящий из элементов от начала
диапазона (0) до конца диапазона не включительно (99)

а второй -- возвращает элементы от начала диапазона до конца 
диапазона включительно (0...100)

Stream можно получить конкатенацией двух других Stream'ов:

IntStream combinedStream =
	IntStream.concat(stream1, stream2);

или взять пустой stream

IntStream empty = IntStream.empty();

или получить stream из массива:

double[] array = ...;
DoubleStream streamFromArray = 
	Arrays.stream(array);

или, что уже совсем неинтересно, просто взять и перечислить все
элементы stream'а явно:

IntStream streamOfElements =
	IntStream.of(2, 4, 6, 8, 10);

способов получить Stream -- огромное количество, этот список не 
является исчерпывающим

## Второй этап

Второй этап -- это промежуточные операции

IntStream stream = ...;

stream.filter(n -> n > 100)
	.mapToObj(Integer::toString)
	.flatMapToInt(s -> s.chars())
	.distinct()
	.sorted()
	.skip(3)
	.limit(2);

операция filter принимает предикат (Predicate)

операция mapToObj принимает функцию (Function), которая из каждого
элемента stream'а делает какой-то новый элемент потенциально
другого типа; в данном случае мы каждое число конвертируем в строку
при помощи метода Integer::toString

операция flatMapToInt принимает функцию, возвращающую stream,
а далее она применяет эту операцию к каждому элементы и получившиеся
stream'ы конкатенирует, то есть на выходе у нас опять плоский
IntStream

операция distinct занимается тем, что убирает из stream'а дубликаты
элементов

операция sorted преобразует stream таким образом, что элементы в нем
начинают идти по порядку возрастания, в случае если у нас Stream
не примитивных типов, а объектов, то туда можно передать Компаратор

операция skip позволяет пропустить некоторое количество первых
элементов, в данном случае нас не интересуют первые 3 

операция limit ограничивает оставшиеся элементы заданным количеством

в данном случае мы получим stream из двух элементов

## Третий этап

третий этап -- это терминальные операции, производящие какой-то
полезный результат

терминальная операция запускает stream на исполнение, приведем
несколько примеров

IntStream stream1 = ...;
stream1.forEach(System.out::println);

forEach принимает Consumer'а, которому будут отданы все элементы
stream'а, которые остались, в данном случае будут выведены в консоль

метод findFirst возвращает первый в порядке следования элемент
из stream'а:

IntStream stream2 = ...;
OptionalInt result = stream2.findFirst();

findAny() не гарантирует, что вернется первый элемент, вернется тот
элемент, который Stream'у удобнее

терминальная операция allMatch позволяет проверить, что все элементы
stream'а удовлетворяют переданному условию предикату:

Stream<String> stream3 = ...;
boolean allStringsAreAtLeast10Chars =
	stream3.allMatch(s -> s.length() > 10);

есть аналогичные методы anyMatch и noneMatch

терминальная операция min возвращает минимальный элемент из stream'а
аналогично в виде Optional, потому что Stream может быть пустой

Stream<String> stream1 = ...;
Optional<String> minString = stream1.min(
	Comparator.comparing(
		String::length, Integer::compare));

есть также операция max

min и max в случае stream'а объектов принимают Comparator, правила
по которым определяются минимум и максимум

операция count возвращает просто количество элементов, оставшихся
в stream'е после применения всех трансформаций и фильтраций

а операция sum вернет обычную арифметическую сумму элементов

IntStream stream3 = ...;
imt sum = stream3.sum();

терминальная операция collect позволяет собрать элементы stream'а
в какое-то новое хранилище, например, в список:

Stream<String> stream1 = ...;
List<String> list =
		stream1.collect(Collectors.toList());

тип этого нового хранилища определяется параметром, который 
передается в метод collect, это некий Collector, и он может
собирать элементы stream'а во что угодно, не только в коллекции

многие стандартные коллекторы есть в классе Collectors

и, наконец, терминальная операция reduce позволяет вычислить
свертку элементов stream'а, то есть результат применения некоторого
бинарного оператора к каждой паре элементов stream'а, пока
от stream'а не останется один единственный элемент

Stream<BigInteger> bigInts = ...;
BigInteger sum = bigInts.reduce(
	BigInteger.ZERO, BigInteger::add);

если stream был пуст, то возвращается некоторое нулевое значение

важно, что вызвать на stream'е терминальную операцию можно только
один раз; после вызова терминальной операции stream считается 
непригодным к использованию и этот объект остается только выбросить

public static BigInteger factorial(int n) {

	return IntStream.rangeClosed(1, n)
		.mapToObj(i -> BigInteger.valueOf(i))
		.reduce(BigInteger.ONE, BigInteger::multiply);

}



}























