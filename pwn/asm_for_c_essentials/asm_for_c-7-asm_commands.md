#Структуры

Объявляя структуры в Си, вы не задумывались о том, как располагаются в 
памяти её элементы. В ассемблере понятия «структура» нет, зато есть 
«блок памяти», его адрес и смещение в этом блоке. Объясню на примере:

`0x23` `0x72` `0x45` `0x17`

Пусть этот блок памяти размером 4 байта расположен по адресу 
`0x00010000`. Это значит, что адрес байта `0x23` равен `0x00010000`. 
Соответственно, адрес байта `0x72` равен `0x00010001`. Говорят, что 
байт `0x72` расположен по смещению 1 от начала блока памяти. Тогда байт
`0x45` расположен по смещению 2, а байт `0x17` — по смещению 3. Таким 
образом, адрес элемента = **базовый адрес + смещение**.

Приблизительно так в ассемблере организована работа со структурами: к 
базовому адресу структуры прибавляется смещение, по которому находится 
нужный элемент. Теперь вопрос: как определить смещение? В Си компилятор
руководствуется следующими правилами:

  * Вся структура должна быть выровнена так, как выровнен её элемент 
  с наибольшим выравниванием.

  * Каждый элемент находится по наименьшему следующему адресу с 
  подходящим выравниванием. Если необходимо, для этого в структуру 
  включается нужное число байт-заполнителей.

  * Размер структуры должен быть кратен её выравниванию. Если 
  необходимо, для этого в конец структуры включается нужное число 
  байт-заполнителей.

Примеры (внизу указано смещение элементов в байтах; заполнители 
обозначены `XX`):

```
struct     Выравнивание структуры: 1, размер: 1
{          +----+
  char c;  | c  |
};         +----+
             0

struct     Выравнивание структуры: 2, размер: 4
{          +----+----+----+----+
  char c;  | c  | XX |    s    |
  short s; +----+----+----+----+
};          0         2

struct     Выравнивание структуры: 4, размер: 8
{          +----+----+----+----+----+----+----+----+
  char c;  | с  | XX   XX   XX |         i         |
  int i;   +----+----+----+----+----+----+----+----+
};          0                   4

struct     Выравнивание структуры: 4, размер: 8
{          +----+----+----+----+----+----+----+----+
  int i;   |         i         | c  | XX   XX   XX |
  char c;  +----+----+----+----+----+----+----+----+
};          0                   4

struct     Выравнивание структуры: 4, размер: 12
{          +----+----+----+----+----+----+----+----+----+----+----+----+
  char c;  | c  | XX   XX   XX |         i         |    s    | XX   XX |
  int i;   +----+----+----+----+----+----+----+----+----+----+----+----+
  short s;  0                   4                   8
};

struct     Выравнивание структуры: 4, размер: 8
{          +----+----+----+----+----+----+----+----+
  int i;   |         i         | c  | XX |    s    |
  char c;  +----+----+----+----+----+----+----+----+
  short s;  0                   4         6
};
```

Обратите внимание на два последних примера: элементы структур одни и 
те же, только расположены в разном порядке. Но размер структур 
получился разный!

##Программа: вывод размера файла	

Напишем программу, которая выводит размер файла. Для этого потребуется 
вызвать функцию `stat(2)` и прочитать данные из структуры, которую она 
заполнит. `man 2 stat`:

```
STAT(2)                  Системные вызовы                  STAT(2)
 
ИМЯ
        stat, fstat, lstat - получить статус файла
		 
КРАТКАЯ СВОДКА
		#include <sys/types.h>
		#include <sys/stat.h>
		#include <unistd.h>
							   
		int stat(const char *file_name, struct stat *buf);

ОПИСАНИЕ
		stat возвращает информацию о файле, заданном с помощью 
		file_name, и заполняет буфер buf.

		Все эти функции возвращают структуру stat, которая содержит 
		такие поля:

			struct stat {
				dev_t         st_dev;     /* устройство  */
				ino_t         st_ino;     /* индексный дескриптор  */
				mode_t        st_mode;    /* режим доступа  */
				nlink_t       st_nlink;   /* количество жестких ссылок */
				uid_t         st_uid;     /* идентификатор 
										пользователя-владельца  */
				gid_t         st_gid;     /* идентификатор 
										группы-владельца  */
				dev_t         st_rdev;    /* тип устройства (если это 
										устройство)       */
				off_t         st_size;    /* общий размер в байтах  */
				unsigned long st_blksize; /* размер блока ввода-вывода */
										/* в файловой системе  */
				unsigned long st_blocks;  /* количество выделенных 
											блоков  */
				time_t        st_atime;   /* время последнего доступа  */
				time_t        st_mtime;   /* время последнего 
											изменения  */
				time_t        st_ctime;   /* время последней смены 
											состояния  */
};
```

Так, теперь осталось только вычислить смещение поля `st_size`… Но что 
это за типы — `dev_t`, `ino_t`? Какого они размера? Следует заглянуть 
в заголовочный файл и узнать, что обозначено при помощи `typedef`.
Например так:

```
[user@host:~]$ cpp /usr/include/sys/types.h | less
```

Но самый верный способ не ошибиться — это просто попросить компилятор 
Си посчитать это смещение для нас (вычитаем из адреса поля адрес 
структуры, получаем смещение):

```
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main()
{
	struct stat t;
	printf("sizeof = %zu, offset = %td\n",
			sizeof(t),
			((void *) &t.st_size) - ((void *) &t));
	return 0;
}
```

На моей системе программа напечатала `sizeof = 88, offset = 44`. На 
вашей системе это значение может отличаться по описанным причинам. 
Теперь у нас есть все нужные данные об этой структуре, пишем 
программу:

```
.data
str_usage:
		.string "usage: %s filename\n"
		 
printf_format:
		.string "%u\n"
				  
.text
.globl main
main:
		pushl %ebp
		movl  %esp, %ebp

		subl  $88, %esp         /* выделить 88 байт под struct stat */

		cmpl  $2, 8(%ebp)       /* argc == 2?                       */
		je    args_ok
								/* программе передали не 2 аргумента, 
								вывести usage  */
		movl  12(%ebp), %ebx    /* поместить в %ebx адрес массива argv 
*/
		pushl (%ebx)            /* argv[0]                          */
		pushl $str_usage
		call  printf

		movl  $1, %eax          /* выйти с кодом 1                  */
		jmp   return

args_ok:
		leal  -88(%ebp), %ebx   /* поместить адрес структуры в 
								регистр %ebx                      */
		pushl %ebx

		movl  12(%ebp), %ecx    /* поместить в %ecx адрес массива argv 
*/
		pushl 4(%ecx)           /* argv[1] — имя файла            */
		call  stat

		cmpl  $0, %eax          /* stat() вернул 0?               */
		je    stat_ok

		/* stat() вернул ошибку, нужно вызвать perror(argv[1]) и 
			завершить программу */

		movl  12(%ebp), %ecx
		pushl 4(%ecx)
		call  perror

		movl  $1, %eax
		jmp   return

stat_ok:
		pushl 44(%ebx)          /* нужное нам поле по смещению 44   */
		pushl $printf_format
		call  printf

		movl  $0, %eax          /* выйти с кодом 0                  */

return:
		movl  %ebp, %esp
		popl  %ebp
		ret
```

Обратите внимание на обработку ошибок: если передано не 2 аргумента — 
выводим описание использования программы и выходим, если `stat(2)` 
вернул ошибку — выводим сообщение об ошибке и выходим.

Наверное, могут возникнуть некоторые сложности с пониманием, как 
расположены `argc` и `argv` в стеке. Допустим, вы запустили программу 
как

```
[user@host:~]$ ./program test-file
```

Тогда стек будет выглядеть приблизительно так:

```
.                        .
.                        .
.                        .
+------------------------+ 0x0000EFE4 <-- %ebp - 88
|       struct stat      |
+------------------------+ 0x0000F040 <-- %ebp
|  старое значение %ebp  |
+------------------------+ 0x0000F044 <-- %ebp + 4
|     адрес возврата     |
+------------------------+ 0x0000F048 <-- %ebp + 8
|          argc          |
+------------------------+ 0x0000F04C <-- %ebp + 12
|  указатель на argv[0]  | ---------------------------- 
+------------------------+ 0x0000F050 <-- %ebp + 16   | 
.                        .              --------------- 
.                        .              | 
.                        .              V 
                                 +-------------+        +-------------+
								 | argv[0]     | -----> | "./program" |
								 +-------------+        +-------------+
								 | argv[1]     | -\
								 +-------------+   \    +-------------+
								 | argv[2] = 0 |    \-> | "test-file" |
								 +-------------+        +-------------+
```

Таким образом, в стек помещается два параметра: `argc` и указатель на 
первый элемент массива `argv[]`. Где-то в памяти расположен блок из 
трёх указателей: указатель на строку `"./program"`, указатель на 
строку `"test-file"` и указатель `NULL`. Нам в стеке передали адрес 
этого блока памяти.

Мы можем использовать директиву препроцессора `#define`.
Препроцессор Си (cpp) может быть использован для обработки исходного 
кода на ассемблере: нужно всего лишь использовать расширение `.S` для 
файла с исходным кодом. Файлы с таким расширением gcc предварительно 
обрабатывает препроцессором cpp, после чего компилирует как обычно.
Например:

```
.data
printf_format:
		.string "<%s>\n"

#define READ_CHUNK 128

.text

/* char *read_str(int *is_eof) */
read_str:
```

#Операции с цепочками данных

При обработке данных часто приходится иметь дело с цепочками данных. 
Цепочка, как подсказывает название, представляет собой массив данных —
несколько переменных одного размера, расположенных друг за другом в 
памяти. В Си вы использовали массив и индексную переменную, например, 
`argv[i]`. Но в ассемблере для последовательной обработки цепочек есть
специализированные команды. Синтаксис:

```
lods
stos
```

«Странно», — скажет кто-то, — «откуда эти команды знают, где брать 
данные и куда их записывать? Ведь у них и аргументов-то нет!» 
Вспомните про регистры `%esi` и `%edi` и про их немного странные 
имена: «индекс источника» (англ. source index) и «индекс приёмника» 
(англ. destination index). Так вот, все цепочечные команды 
подразумевают, что в регистре `%esi` находится указатель на следующий 
необработанный элемент цепочки-источника, а в регистре `%edi` — 
указатель на следующий элемент цепочки-приёмника.

Направление просмотра цепочки задаётся флагом `df`: 0 — просмотр 
вперед, 1 — просмотр назад.

Итак, команда `lods` загружает элемент из цепочки-источника в регистр 
`%eax`/`%ax`/`%al` (размер регистра выбирается в зависимости от 
суффикса команды). После этого значение регистра `%esi` увеличивается 
или уменьшается (в зависимости от направления просмотра) на значение, 
равное размеру элемента цепочки.

Команда `stos` записывает содержимое регистра `%eax`/`%ax`/`%al` в 
цепочку-приёмник. После этого значение регистра `%edi` увеличивается 
или уменьшается (в зависимости от направления просмотра) на значение, 
равное размеру элемента цепочки.

Вот пример программы, которая работает с цепочечными командами. 
Конечно же, она занимается бестолковым делом, но в противном случае 
она была бы гораздо сложнее. Она увеличивает каждый байт строки 
`str_in` на 1, то есть заменяет a на b, b на с, и так далее.

```
.data
printf_format:
		.string "%s\n"

str_in:
		.string "abc123()!@!777"
		.set str_in_length, .-str_in

.bss
str_out:
		.space str_in_length

.text
.globl main
main:
		pushl %ebp
		movl  %esp, %ebp

		movl  $str_in, %esi     /* цепочка-источник                */
		movl  $str_out, %edi    /* цепочка-приёмник                */

		movl  $str_in_length - 1, %ecx  /* длина строки без нулевого 
								байта (нулевой байт не обрабатываем)
																	*/
1:
		lodsb                   /* загрузить байт из источника в %al  */
		incb  %al               /* произвести какую-то операцию с %al */

		stosb                   /* сохранить %al в приёмнике        */
		loop  1b

		movsb                   /* копировать нулевой байт          */

		/* важно: сейчас %edi указывает на конец цепочки-приёмника  */

		pushl $str_out
		pushl $printf_format
		call  printf            /* вывести на печать                */

		movl  $0, %eax

		movl  %ebp, %esp
		popl  %ebp
		ret
```

```
[user@host:~]$ ./stringop
bcd234)*"A"888
[user@host:~]$ 
```

Но с цепочками мы часто выполняем довольно стандартные действия. 
Например, при копировании блоков памяти мы просто пересылаем байты из 
одной цепочки в другую, без обработки. При сравнении строк мы 
сравниваем элементы двух цепочек. При вычислении длины строки в Си мы 
считаем байты до тех пор, пока не встретим нулевой байт. Эти действия 
очень просты, но, в тоже время, используются очень часто, поэтому были
введены следующие команды:

```
movs
cmps
scas
```

Размер элементов цепочки, которые обрабатывают эти команды, зависит от
использованного суффикса команды.

Команда `movs` выполняет копирование одного элемента из 
цепочки-источника в цепочку-приёмник.

Команда `cmps` выполняет сравнение элемента из цепочки-источника и 
цепочки-приёмника (фактически, как и `cmp`, выполняет вычитание, 
источник — приёмник, результат никуда не записывается, но флаги 
устанавливаются).

Команда `scas` предназначена для поиска определённого элемента в 
цепочке. Она сравнивает содержимое регистра `%eax`/`%ax`/`%al` и 
содержимое элемента цепочки (выполняется вычитание `%eax`/`%ax`/`%al` 
— элемент_цепочки, результат не записывается, но флаги 
устанавливаются). Адрес цепочки должен быть помещён в регистр `%edi`.

После того, как эти команды выполнили своё основное действие, они 
увеличивают/уменьшают индексные регистры на размер элемента цепочки.

Подчеркну тот факт, что эти команды обрабатывают **только один** 
элемент цепочки. Таким образом, нужно организовать что-то вроде цикла 
для обработки всей цепочки. Для этих целей существуют префиксы команд:

```
rep
repe/repz
repne/repnz
```

Эти префиксы ставятся перед командой, например: `repe scas`. Префикс 
организовывает как бы цикл из одной команды, при этом с каждым шагом 
цикла значение регистра `%ecx` автоматически уменьшается на 1.

  * `rep` повторяет команду, пока `%ecx` не равен нулю.
  * `repe` (или `repz` — то же самое) повторяет команду, пока `%ecx` 
  не равен нулю и установлен флаг `zf`. Анализируя значение регистра 
  `%ecx`, можно установить точную причину выхода из цикла: если 
  `%ecx` равен нулю, значит, `zf` всегда был установлен, и вся цепочка
  пройдена до конца, если `%ecx` больше нуля — значит, флаг `zf` в 
  какой-то момент был сброшен. 

  * `repne` (или `repnz` — то же самое) повторяет команду, пока 
  `%ecx` не равен нулю и не установлен флаг `zf`.

Также следует указать команды для управления флагом `df`:

```
cld
std
```

`cld` (CLear Direction flag) сбрасывает флаг `df`.

`std` (SeT Direction flag) устанавливает флаг `df`.

##Пример: memcpy

Вооружившись новыми знаниями, попробуем заново изобрести функцию 
`memcpy(3)`:

```
.data
printf_format:
		.string "%s\n"

str_in:
		.string "abc123()!@!777"
		.set str_in_length, .-str_in

.bss
str_out:
		.space str_in_length

.text

/* void *my_memcpy(void *dest, const void *src, size_t n); */

my_memcpy:
		pushl %ebp
		movl  %esp, %ebp

		pushl %esi
		pushl %edi

		movl  8(%ebp), %edi     /* цепочка-назначение              */
		movl  12(%ebp), %esi    /* цепочка-источник                */
		movl  16(%ebp), %ecx    /* длина                           */

		rep movsb

		movl  8(%ebp), %eax     /* вернуть dest                   */

		popl  %edi
		popl  %esi

		movl  %ebp, %esp
		popl  %ebp
		ret

.globl main
main:
		pushl %ebp
		movl  %esp, %ebp

		pushl $str_in_length
		pushl $str_in
		pushl $str_out
		call  my_memcpy

		pushl $str_out
		pushl $printf_format
		call  printf

		movl  $0, %eax

		movl  %ebp, %esp
		popl  %ebp
		ret
```

Вы, наверно, будете удивлены, если я вам скажу, что эта реализация 
`memcpy` всё равно не самая быстрая. «Что ещё можно сделать?» — 
спросите вы. Ведь мы можем копировать данные не по одному байту, а по 
целых 4 байта за раз при помощи `movsl`. Тогда у нас получается 
приблизительно такой алгоритм: копируем как можно больше данных 
блоками по 4 байта, после этого остаётся хвостик в 0, 1, 2 или 3 
байта; этот остаток можно скопировать при помощи `movsb`. Поэтому 
нашу `memcpy` лучше переписать вот так:

```
/* void *my_memcpy(void *dest, const void *src, size_t n); */

my_memcpy:
		pushl %ebp
		movl  %esp, %ebp

		pushl %esi
		pushl %edi

		movl  8(%ebp), %edi     /* цепочка-назначение              */
		movl  12(%ebp), %esi    /* цепочка-источник                */
		movl  16(%ebp), %edx    /* длина                           */

		movl  %edx, %ecx
		shrl  $2, %ecx          /* делить на 2^2 = 4; теперь в 
								находится %ecx количество 4-байтных 
								кусочков                          */
		rep movsl

		movl  %edx, %ecx
		andl  $3, %ecx          /* $3 == $0b11, оставить только два 
								младших бита, то есть остаток от 
								деления на 4                      */
		jz    1f                /* если результат 0, пропустить 
								цепочечную команду                */
		rep movsb
1:

		movl  8(%ebp), %eax     /* вернуть dest                   */

		popl  %edi
		popl  %esi

		movl  %ebp, %esp
		popl  %ebp
		ret
```

##Пример: strlen

Теперь `strlen`: нам нужно сравнить каждый байт цепочки с 0, 
остановиться, когда найдём 0, и вернуть количество ненулевых байт. 
Как счетчик мы будем использовать регистр `%ecx`, который 
автоматически изменяют все префиксы. Но префиксы уменьшают счетчик и 
прекращают выполнение команды, когда `%ecx` равен 0. Поэтому перед 
цепочечной командой мы поместим в `%ecx` число `0xffffffff`, и этот 
регистр будет уменьшатся в ходе выполнения цепочечной команды. 
Результат получится в обратном коде, поэтому мы используем команду 
`not` для инвертирования всех битов. И после этого ещё уменьшим 
результат на 1, так как нулевой байт тоже был посчитан.

```
.data
printf_format:
		.string "%u\n"

str_in:
		.string "abc123()!@!777"

.text

/* size_t my_strlen(const char *s); */

my_strlen:
		pushl %ebp
		movl  %esp, %ebp

		pushl %edi

		movl  8(%ebp), %edi             /* цепочка */

		movl  $0xffffffff, %ecx
		xorl  %eax, %eax                /* %eax = 0 */

		repne scasb

		notl  %ecx
		decl  %ecx

		movl  %ecx, %eax

		popl  %edi

		movl  %ebp, %esp
		popl  %ebp
		ret

.globl main
main:
		pushl %ebp
		movl  %esp, %ebp

		pushl $str_in
		call  my_strlen

		pushl %eax
		pushl $printf_format
		call  printf

		movl  $0, %eax

		movl  %ebp, %esp
		popl  %ebp
		ret
```

В заключение обсуждения цепочечных команд нужно сказать следующее: не 
следует заново изобретать стандартные функции, как мы это только что 
сделали. Это всего лишь пример и объяснение принципов их работы. В 
реальных программах используйте цепочечные команды, только когда они 
реально смогут помочь при нестандартной обработке цепочек, а для 
стандартных операций лучше вызывать библиотечные функции.

#Конструкция switch

Оператор `switch` языка Си можно переписать на ассемблере разными 
способами. Рассмотрим несколько вариантов того, какими могут быть 
значения у case:

  * значения из определённого маленького промежутка (все или почти 
  все), например, 23, 24, 25, 27, 29, 30;
  * значения, между которыми большие «расстояния» на числовой прямой, 
  например, 5, 15, 80, 3800;
  * комбинированный вариант: 35, 36, 37, 38, 39, 1200, 1600, 7000.

Рассмотрим решение для первого случая. Вспомним, что команда `jmp` 
принимает адрес не только в виде непосредственного значения (метки), 
но и как обращение к памяти. Значит, мы можем осуществлять переход на 
адрес, вычисленный в процессе выполнения. Теперь вопрос: как можно 
вычислить адрес? А нам не нужно ничего вычислять, мы просто поместим 
все адреса case-веток в массив. Пользуясь проверяемым значением как 
индексом массива, выбираем нужный адрес case-ветки. Таким образом, 
процессор всё вычислит за нас. Посмотрите на следующий код:

```
.data
printf_format:
		.string "%u\n"

.text
.globl main

main:
		pushl %ebp
		movl  %esp, %ebp

		movl  $1, %eax          /* получить в %eax некоторое 
								интересующее нас значение         */

								/* мы предусмотрели случаи только для 
								0, 1, 3, поэтому,                 */
		cmpl  $3, %eax          /* если %eax больше 3 
								(как беззнаковое),                */
		ja    case_default      /* перейти к default              */

		jmp   *jump_table(,%eax,4) /* перейти по адресу, содержащемуся 									в памяти jump_table + %eax*4      */

.section .rodata
		.p2align 4
jump_table:                     /* массив адресов                  */
		.long case_0            /* адрес этого элемента массива: 
													jump_table + 0  */
		.long case_1            /*                  jump_table + 4  */
		.long case_default      /*                  jump_table + 8  */
		.long case_3            /*                  jump_table + 12 */
.text

case_0:
		movl  $5, %ecx          /* тело case-блока                 */
		jmp   switch_end        /* имитация break — переход в конец 
								switch                            */

case_1:
		movl  $15, %ecx
		jmp   switch_end

case_3:
		movl  $35, %ecx
		jmp   switch_end

case_default:
		movl  $100, %ecx

switch_end:

		pushl %ecx              /* вывести %ecx на экран, выйти    */
		pushl $printf_format
		call  printf

		movl  $0, %eax

		movl  %ebp, %esp
		popl  %ebp
		ret
```

Этот код эквивалентен следующему коду на Си:

```
#include <stdio.h>

int main()
{
	unsigned int a, c;

	a = 1;
	switch(a)
	{
		case 0:
			c = 5;
			break;

		case 1:
			c = 15;
			break;

		case 3:
			c = 35;
			break;

		default:
			c = 100;
			break;
	}

	printf("%u\n", c);
	return 0;
}
```

Смотрите: в секции `.rodata` (данные только для чтения) создаётся 
массив из 4 значений. Мы обращаемся к нему как к обычному массиву, 
индексируя его по `%eax`: `jump_table(,%eax,4)`. Но зачем перед этим 
стоит звёздочка? Она означает, что мы хотим перейти по адресу, 
содержащемуся в памяти по адресу `jump_table(,%eax,4)` (если бы её не 
было, мы бы перешли по этому адресу и начали исполнять массив 
`jump_table` как код).

Заметьте, что тут нам понадобились значения 0, 1, 3, укладывающиеся в 
маленький промежуток [0; 3]. Так как для значения 2 не предусмотрено 
особой обработки, в массиве адресов `jump_table` индексу 2 
соответствует `case_default`. Перед тем, как сделать `jmp`, нужно 
обязательно убедиться, что проверяемое значение входит в наш 
промежуток, и если не входит — перейти на `default`. Если вы этого не 
сделаете, то, когда попадётся значение, находящееся за пределами 
массива, программа, в лучшем случае, получит `segmentation fault`, а в
худшем (если рядом с этим масивом адресов в памяти окажется еще один 
массив адресов) код продолжит исполнение вообще непонятно где.

Теперь рассмотрим случай, когда значения для веток case находятся на 
большом расстоянии друг от друга. Очевидно, что способ с массивом 
адресов не подходит, иначе массив занимал бы большое количество памяти
и содержал в основном адреса ветки `default`. В этом случае лучшее, 
что может сделать программист, — выразить `switch` как 
последовательное сравнение со всеми перечисленными значениями. Если 
значений довольно много, придётся применить немного логики: 
приблизительно прикинуть, какие ветки будут исполняться чаще всего, и 
отсортировать их в таком порядке в коде. Это нужно для того, чтобы 
наиболее часто исполняемые ветки исполнялись после маленького числа 
сравнений. Допустим, у нас есть варианты 5, 38, 70 и 1400, причём 70 
будет появляться чаще всего:

```
.data
printf_format:
		.string "%u\n"

.text
.globl main

main:
		pushl %ebp
		movl  %esp, %ebp

		movl  $70, %eax         /* получить в %eax некоторое 
								интересующее нас значение         */

		cmpl  $70, %eax
		je    case_70

		cmpl  $5, %eax
		je    case_5

		cmpl  $38, %eax
		je    case_38

		cmpl  $1400, %eax
		je    case_1400

case_default:
		movl  $100, %ecx
		jmp   switch_end

case_5:
		movl  $5, %ecx
		jmp   switch_end

case_38:
		movl  $15, %ecx
		jmp   switch_end

case_70:
		movl  $25, %ecx
		jmp   switch_end

case_1400:
		movl  $35, %ecx

switch_end:

		pushl %ecx

		pushl $printf_format
		call  printf

		movl  $0, %eax

		movl  %ebp, %esp
		popl  %ebp
		ret
```

Единственное, на что хочется обратить внимание, — на расположение 
ветки `default`: если все сравнения оказались ложными, код `default` 
выполняется автоматически.

Наконец, третий, комбинированный, вариант. Путь имеем варианты 35, 36,
37, 39, 1200, 1600 и 7000. Тогда мы видим промежуток [35; 39] и ещё 
три числа. Код будет выглядеть приблизительно так:

```
		movl  $1, %eax          /* получить в %eax некоторое 
								интересующее нас значение         */

		cmpl  $35, %eax
		jb    case_default

		cmpl  $39, %eax
		ja    switch_compare

		jmp   *jump_table-140(,%eax,4)

.section .rodata
		.p2align 4
jump_table:
		.long case_35
		.long case_36
		.long case_37
		.long case_default
		.long case_39
.text

switch_compare:
		cmpl  $1200, %eax
		jmp   case_1200

		cmpl  $1600, %eax
		jmp   case_1600

		cmpl  $7000, %eax
		jmp   case_7000

case_default:
		/* ... */
		jmp   switch_end

case_35:
		/* ... */
		jmp   switch_end

		... ещё код ...
switch_end:
```

Заметьте, что промежуток начинается с числа 35, а не с 0. Для того, 
чтобы не производить вычитание 35 отдельной командой и не создавать 
массив, в котором от 0 до 34 идёт адреса метки default, сначала 
проверяется принадлежность числа промежутку [35; 39], а затем 
производится переход, но массив адресов считается размещённым на 35 
двойных слов «ниже» в памяти (то есть, на 35 × 4 = 140 байт). 
В результате получается, что адрес перехода считывается из памяти по 
адресу `jump_table - 35*4 + %eax*4 = jump_table + (%eax - 35)*4`. 
Выиграли одно вычитание.

В этом примере, как и в предыдущих, имеет смысл переставить некоторые 
части этого кода в начало, если вы заранее знаете, какие значения вам 
придётся обрабатывать чаще всего.

#Булевы выражения	

Рассмотрим такой код на языке Си:

```
if(((a > 5) && (b < 10)) || (c == 0))
{
	do_something();
}
```

В принципе, булево выражение можно вычислять как обычное 
арифметическое, то есть в такой последовательности:

  * `a > 5`
  * `b < 10`
  * `(a > 5) && (b < 10)`
  * `c == 0`
  * `((a > 5) && (b < 10)) || (c == 0)`

Такой способ вычисления называется полным. Можем ли мы вычислить 
значение этого выражения быстрее? Смотрите, если `c == 0`, то всё 
выражение будет иметь значение true в любом случае, независимо 
от `a` и `b`. А вот если `c != 0`, то приходится проверять значения 
`a` и `b`. Таким образом, наш код (фактически) превращается в такой:

```
if(c == 0)
{
	goto do_it;
}
if((a > 5) && (b < 10))
{
	goto do_it;
}
goto dont_do_it;

do_it:
	do_something();

dont_do_it:
```

В принципе, можно пойти дальше: если `a <= 5`, нас не интересует 
сравнение `b < 10`: всё равно выражение равно false.

```
if(c == 0)
{
	goto do_it;
}
if(a > 5)
{
	if(b < 10)
	{
		goto do_it;
	}
}
goto dont_do_it;

do_it:
	do_something();

dont_do_it:
```

Такой способ вычисления выражений называется **сокращённым** (от англ.
short-circuit evaluation), потому что позволяет вычислить выражение, 
не проверяя всех входящих в него подвыражений. Можно вывести такие 
формальные правила:

  * если у оператора OR хотя бы один операнд имеет значение true, всё 
  выражение имеет значение true;
  * если у оператора AND хотя бы один операнд имеет значение false, 
  всё выражение имеет значение false.

В принципе, сокращённое вычисление булевых выражений помогает 
написать более быстрый (а часто и более простой) код. С другой 
стороны, возникают проблемы, если одно из подвыражений при 
вычислении вызывает побочные эффекты (англ. side effects), например 
вызов функции:

```
if((c == 0) || foo())
{
	do_something();
}
```

Если мы используем сокращённое вычисление и оказывается, 
что `c == 0`, то функция `foo()` вызвана не будет, потому что от её 
результата значение выражения уже не зависит. Хорошо это или плохо, 
зависит от конкретной ситуации, но, без сомнения, способ выполнения 
такого кода становится не очевидным.

Во многих языках высокого уровня сокращённое вычисление выражений 
требуется от компилятора стандартом языка (например, в Си). Однако, 
обычно задаются более строгие правила вычислений. В большинстве 
стандартов языков требуется, чтобы выражения соединённые оператором 
OR (или AND) вычислялись строго слева направо, и если очередное 
значение будет true (соответственно, false для AND), то вычисление 
данной цепочки OR-ов (AND-ов) прекращается. 

Но нужно отметить, что первый пример в этой главе всё равно является 
корректным с точки зрения стандарта Си (хотя `c == 0` стоит в конце 
выражения, а вычисляется первым), так как сравнение локальных 
переменных не вызывает побочных эффектов и компилятор вправе 
реорганизовать код таким образом.

Теперь перейдём к тому, как это реализовывается на ассемблере. 
Начнём с полного вычисления:

```
cmpl  $5, a
/* так, а что дальше? */
```

Действительно, нам нужно сохранить результат сравнения в переменную. Из команд, анализирующих флаги, мы знаем только семейство `jcc`, но 
они нам не подходят. Кроме `jcc`, существует семейство `setcc`. Они 
проверяют состояние флагов точно так же, как и `jcc`. На основе 
флагов операнд устанавливается в 1, если проверяемое условие `cc` 
истинно, и в 0, если условие ложно.

```
setcc операнд
```

Требуется заметить, что команды `setcc` работают только с операндами 
(хранящимися в регистрах и памяти) размером один байт.

Тогда полное вычисление будет выглядеть так:

```
		cmpl  $5, a
		seta  %al
		cmpl  $10, b
		setb  %bl
		andb  %bl, %al
		cmpl  $0, c
		sete  %bl
		orb   %bl, %al
		jz    is_false
is_true:
		...
is_false:
		...
```

Обратите внимание, что команда `or` устанавливает флаги, и нам не 
нужно отдельно сравнивать `%al` с нулём.

Сокращённое вычисление:

```
		cmpl  $0, c
		je    is_true
		cmpl  $5, a
		jbe   is_false
		cmpl  $10, b
		jae   is_false
is_true:
		...
is_false:
		...
```

Как видите, этот код является не только более коротким, но и 
завершает своё исполнение, как только результат становится известен. 
Таким образом, сокращённое вычисление намного быстрее полного.
