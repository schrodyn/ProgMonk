#Арифметика

Арифметических команд в нашем распоряжении довольно много. Синтаксис:

```
inc   операнд
dec   операнд

add   источник, приёмник
sub   источник, приёмник

mul   множитель_1
```

Принцип работы:

  * `inc`: увеличивает операнд на 1.
  * `dec`: уменьшает операнд на 1.
  * `add`: приёмник = приёмник + источник (то есть, увеличивает 
  приёмник на источник).
  * `sub`: приёмник = приёмник - источник (то есть, уменьшает 
  приёмник на источник).

Команда `mul` имеет только один операнд. Второй сомножитель задаётся 
неявно. Он находится в регистре `%eax`, и его размер выбирается в 
зависимости от суффикса команды (`b`, `w` или `l`). Место размещения 
результата также зависит от суффикса команды.

Нужно отметить, что результат умножения двух n-разрядных чисел может 
уместиться только в 2n-разрядном регистре результата. В следующей 
таблице описано, в какие регистры попадает результат при той или иной 
разрядности операндов.

Команда	| Второй сомножитель | Результат
--------|--------------------|------------
mulb	|	%al				 | 16 бит: `%ax`
mulw	|	%ax		|	32 бита: младшая часть в `%ax`, старшая в `%dx`
mull	|	%eax	|	64 бита: младшая часть в `%eax`, старшая в `%edx`

Примеры:

```
.text
		movl  $72, %eax
		incl  %eax              /* в %eax число 73                   */
		decl  %eax              /* в %eax число 72                   */
						 
		movl  $48, %eax
		addl  $16, %eax         /* в %eax число 64                   */

		movb  $5, %al
		movb  $5, %bl
		mulb  %bl               /* в регистре %ax произведение 
								%al × %bl = 25                    */
```

Давайте подумаем, каким будет результат выполнения следующего кода на 
Си:

```
char x, y;
x = 250;
y = 14;
x = x + y;
printf("%d", (int) x);
```

Большинство сразу скажет, что результат (250 + 14 = 264) больше, чем 
может поместиться в одном байте. И что же напечатает программа? 8. 
Давайте рассмотрим, что происходит при сложении в двоичной системе.

```
    11111010       250
  + 00001110      + 14
  ----------       ---
  1 00001000       264
   |        |
   |<------>|
	    8 бит
```

Получается, что результат занимает 9 бит, а в переменную может 
поместиться только 8 бит. Это называется **переполнением** — перенос из
старшего бита результата. В Си переполнение не может быть перехвачено, 
но в микропроцессоре эта ситуация регистрируется, и её можно 
обработать.

Когда происходит переполнение, устанавливается флаг `cf`. Команды 
условного перехода `jc` и `jnc` анализируют состояние этого флага. 
Команды условного перехода будут рассмотрены далее, здесь эта 
информация приводится для полноты описания команд.

```
		movb  $0,   %ah         /* %ah = 0		*/
		movb  $250, %al         /* %al = 250	*/
		addb  $14,  %al         /* %al = %al + 14 
								происходит переполнение, 
								устанавливается флаг cf;
								в %al число 8	*/
		jnc   no_carry          /* если переполнения не было, перейти 
								на метку		*/
		movb  $1,   %ah         /* %ah = 1		*/
no_carry:
		/* %ax = 264 = 0x0108 */
```

Этот код выдаёт правильную сумму в регистре `%ax` с учётом 
переполнения, если оно произошло. 

##Команда `lea` для арифметики	

Для выполнения некоторых арифметических операций можно использовать 
команду `lea`. Она вычисляет адрес своего операнда-источника и 
помещает этот адрес в операнд-назначение. Ведь она не производит 
чтение памяти по этому адресу, верно? А значит, всё равно, что она 
будет вычислять: адрес или какие-то другие числа.

Вспомним, как формируется адрес операнда:

```
смещение(база, индекс, множитель)
```

Вычисленный адрес будет равен `база + индекс × множитель + смещение`.

```
movl  $10, %eax
movl  $7, %ebx
 
 leal  5(%eax)       ,%ecx  /* %ecx = %eax + 5 = 15		*/
 leal  -3(%eax)      ,%ecx  /* %ecx = %eax - 3 = 7		*/
 leal  (%eax,%ebx)   ,%ecx  /* %ecx = %eax + %ebx × 1 = 17		*/
 leal  (%eax,%ebx,2) ,%ecx  /* %ecx = %eax + %ebx × 2 = 24		*/
 leal  1(%eax,%ebx,2),%ecx  /* %ecx = %eax + %ebx × 2 + 1 = 25	*/
 leal  (,%eax,8)     ,%ecx  /* %ecx = %eax × 8 = 80		*/
 leal  (%eax,%eax,2) ,%ecx  /* %ecx = %eax + %eax × 2 = %eax × 3 = 30 */
 leal  (%eax,%eax,4) ,%ecx  /* %ecx = %eax + %eax × 4 = %eax × 5 = 50 */
 leal  (%eax,%eax,8) ,%ecx  /* %ecx = %eax + %eax × 8 = %eax × 9 = 90 */
 ```

 Вспомните, что при сложении командой `add` результат записывается на 
 место одного из слагаемых. Теперь, наверно, стало ясно главное 
 преимущество `lea` в тех случаях, где её можно применить: она **не 
 перезаписывает** операнды-источники.

 Также `lea` можно применять для умножения регистра на 3, 5 и 9, как 
 показано выше.

##Команда `loop`

Синтаксис:

```
loop  метка
```

Принцип работы:

  * уменьшить значение регистра `%ecx` на 1;
  * если `%ecx = 0`, передать управление следующей за `loop` команде;
  * если `%ecx ≠ 0`, передать управление на метку.

Напишем программу для вычисления суммы чисел от 1 до 10

```
.data
printf_format:
		.string "%d\n"
		 
.text
.globl main
main:
		movl  $0, %eax          /* в %eax будет результат, поэтому в 
								начале его нужно обнулить         */
		movl  $10, %ecx         /* 10 шагов цикла			*/
															 
sum:
		addl  %ecx, %eax        /* %eax = %eax + %ecx		*/
		loop  sum

		/* %eax = 55, %ecx = 0 */
																					   
/*
* следующий код выводит число в %eax на экран и завершает программу
*/
		pushl %eax
		pushl $printf_format
		call  printf
		addl  $8, %esp

		movl  $0, %eax
		ret
```

На Си это выглядело бы так:

```
#include <stdio.h>

int main()
{
	int eax, ecx;
	eax = 0;
	ecx = 10;
	do
	{
		eax += ecx;
	} while(--ecx);
	printf("%d\n", eax);
	return 0;
}
```

##Команды сравнения и условные переходы. Безусловный переход

Команда `loop` неявно сравнивает регистр `%ecx` с нулём. Это довольно 
удобно для организации циклов, но часто циклы бывают намного сложнее, 
чем те, что можно записать при помощи `loop`. К тому же нужен 
эквивалент конструкции `if(){}`. Вот команды, позволяющие выполнять 
произвольные сравнения операндов:

```
cmp   операнд_2, операнд_1
```

Команда `cmp` выполняет вычитание `операнд_1 – операнд_2` и 
устанавливает флаги. Результат вычитания нигде не запоминается.

Сравнили, установили флаги, — и что дальше? А у нас есть целое 
семейство `jump`-команд, которые передают управление другим командам. 
Эти команды называются командами условного перехода. Каждой из них 
поставлено в соответствие условие, которое она проверяет. Синтаксис:

```
jcc   метка
```

Команды `jcc` не существует, вместо `cc` нужно подставить 
мнемоническое обозначение условия.

Мнемоника | Английское слово | Смысл | Тип операндов
----------|------------------|-------|---------------
e			|		equal	|	равенство	|	любые
n	|	not		|	инверсия	|	условия	|	любые
g	|	greater	|	больше	|	со знаком
l	|	less	|	меньше	|	со знаком
a	|	above	|	больше	|	без знака
b	|	below	|	меньше	|	без знака

Таким образом, `je` проверяет равенство операндов команды сравнения, 
`jl` проверяет условие `операнд_1 < операнд_2` и так далее. У каждой 
команды есть противоположная: просто добавляем букву `n`:

  * `je` — `jne`: равно — не равно;
  * `jg` — `jng`: больше — не больше.

```
.text
		/* Тут пропущен код, который получает некоторое значение в 
		%eax. Пусть нас интересует случай, когда %eax = 15 */

		cmpl  $15, %eax         /* сравнение		*/
		jne   not_equal        /* если операнды не равны, перейти на 
								метку not_equal                   */

		/* сюда управление перейдёт только в случае, когда переход не 
		сработал, а значит, %eax = 15 */
	
not_equal:
		/* а сюда управление перейдёт в любом случае */
```

Сравните с кодом на Си:

```
if(eax == 15)
{
/* сюда управление перейдёт только в случае, когда переход не 
	сработал, а значит, %eax = 15 */
}
/* а сюда управление перейдёт в любом случае */
```

Кроме команд условного перехода, область применения которых ясна 
сразу, также существует команда безусловного перехода. Эта команда 
чем-то похожа на оператор `goto` языка Си. Синтаксис:

```
jmp   адрес
```

Эта команда передаёт управление на *адрес*, не проверяя никаких 
условий. Заметьте, что адрес может быть задан в виде непосредственного
значения (метки), регистра или обращения к памяти.

##Произвольные циклы

Все инструкции для написания произвольных циклов мы уже рассмотрели, 
осталось лишь собрать всё воедино. Лучше сначала посмотрите код 
программы, а потом объяснение к ней.

Программа: поиск наибольшего элемента в массиве

```
.data
printf_format:
		.string "%d\n"
		 
array:
		.long -10, -15, -148, 12, -151, -3, -72
array_end:
				  
.text
.globl main
main:
		movl  array, %eax         /* в %eax будет храниться результат;
									в начале наибольшее значение — 
									array[0]*/
		movl  $array+4, %ebx      /* в %ebx находится адрес текущего 
								элемента массива	*/
		jmp   ch_bound          /* проверить границы массива */
loop_start:                     /* начало цикла		*/
		cmpl  %eax, (%ebx)      /* сравнить текущий элемент массива с 
								текущим наибольшим значением из %eax
								*/
		jle   less              /* если текущий элемент массива меньше 								или равен наибольшему, пропустить 
							  следующий код		*/
		movl  (%ebx), %eax      /* а вот если элемент массива 
								превосходит наибольший, значит, его 
								значение и есть новый максимум    */
less:
		addl  $4, %ebx          /* увеличить %ebx на размер одного 
								элемента массива, 4 байта         */
ch_bound:
		cmpl  $array_end, %ebx  /* сравнить адрес текущего элемента и 
								адрес конца массива               */
		jne    loop_start        /* если они не равны, повторить 
								цикл снова */ 

/*
* следующий код выводит число из %eax на экран и завершает программу
*/

		pushl %eax
		pushl $printf_format
		call  printf
		addl  $8, %esp

		movl  $0, %eax
		ret
```

Этот код соответствует приблизительно следующему на Си:

```
#include <stdio.h>
 
 int main()
 {
	static int array[] = { -10, -15, -148, 12, -151, -3, -72 };
	static int *array_end = &array[sizeof(array) / sizeof(int)];
	int max = array[0];
	int *p = array+1;
		  
	while (p != array_end) {
		if(*p > max) {
			max = *p;
		}
		p++;
	}
									   
	printf("%d\n", max);
	return 0;
}
```

Возможно, такой способ обхода массива не очень привычен для вас. В Си 
принято использовать переменную с номером текущего элемента, а не 
указатель на него. Никто не запрещает пойти этим же путём и на 
ассемблере:

```
.data
printf_format:
		.string "%d\n"
		 
array:
		.long 10, 15, 148, -3, 151, 3, 72
array_size:
		.long (. - array)/4  /* количество элементов массива */
						  
.text
.globl main
main:
		movl  array, %eax          /* в %eax будет храниться 
									результат; в начале наибольшее 
									значение — array[0]  */
		movl  $1, %ecx            /* начать просмотр с первого 
									элемента */
		jmp   ch_bound
loop_start:                     /* начало цикла		*/
		cmpl  %eax, array(,%ecx,4)  /* сравнить текущий элемент 
									массива с текущим наибольшим 
									значением из %eax	*/
		jle   less              /* если текущий элемент массива меньше 									или равен наибольшему, пропустить 
								следующий код		*/
		movl  array(,%ecx,4), %eax  /* а вот если элемент массива 
								превосходит наибольший, значит, его 
								значение и есть новый максимум    */
less:
		incl  %ecx              /* увеличить на 1 номер текущего 
								элемента                          */
ch_bound:
		cmpl  array_size, %ecx  /* сравнить номер текущего элемента с 
								общим числом элементов            */
		jne    loop_start       /* если они не равны, повторить цикл 
								снова */

/*
* следующий код выводит число в %eax на экран и завершает программу
*/
		pushl %eax
		pushl $printf_format
		call  printf
		addl  $8, %esp

		movl $0, %eax
		ret
```

Рассматривая код этой программы, вы, наверно, уже поняли, как 
создавать произвольные циклы с постусловием на ассемблере, наподобие 
`do{} while();` в Си. Ещё раз повторю эту конструкцию, выкинув весь 
код, не относящийся к циклу:

```
loop_start:                    /* начало цикла	*/
 
		/* вот тут находится тело цикла */
		  
		cmpl  ...              /* что-то с чем-то сравнить для 
								принятия решения о выходе из цикла */
		jne    loop_start      /* подобрать соответствующую команду 
								условного перехода для повторения 
								цикла     */  
```

В Си есть ещё один вид цикла, с проверкой условия перед входом в 
тело цикла (цикл с предусловием): `while(){}`. Немного изменив 
предыдущий код, получаем следующее:

```
		jmp    check
loop_start:                    /* начало цикла		*/

		/* вот тут находится тело цикла */

check:
		cmpl  ...              /* что-то с чем-то сравнить для 
							принятия решения о выходе из цикла */
		jne    loop_start      /* подобрать соответствующую команду 
							условного перехода для повторения 
							цикла	*/  
```

Кто-то скажет: а ещё есть цикл `for()`! Но цикл

```
for(init; cond; incr)
{
	body;
}
```

эквивалентен такой конструкции:

```
init;
while(cond)
{
	body;
	incr;
}
```

Таким образом, нам достаточно и уже рассмотренных двух видов циклов.

##Логическая арифметика

Кроме выполнения обычных арифметических вычислений, можно проводить и 
логические, то есть битовые.

```
and   источник, приёмник
or    источник, приёмник
xor   источник, приёмник
not   операнд
test  операнд_1, операнд_2
```

Команды `and`, `or` и `xor` ведут себя так же, как и операторы языка 
Си `&`, `|`, `^`. Эти команды устанавливают флаги согласно результату.

Команда `not` инвертирует каждый бит операнда (изменяет на 
противоположный), так же как и оператор языка Си `~`.

Команда `test` выполняет побитовое И над операндами, как и команда 
`and`, но, в отличие от неё, операнды не изменяет, а только 
устанавливает флаги. Её также называют командой логического сравнения,
потому что с её помощью удобно проверять, установлены ли определённые 
биты. Например, так:

```
		testb $0b00001000, %al  /* установлен ли 3-й (с нуля) бит? */
		je    not_set
		/* нужные биты установлены */
not_set:
		/* биты не установлены */
```

Обратите внимание на запись константы в двоичной системе счисления: 
используется префикс `0b`.

Команду `test` можно применять для сравнения значения регистра с 
нулём:

```
		testl %eax, %eax
		je    is_zero
		/* %eax != 0 */
is_zero:
		/* %eax == 0 */
```

Intel Optimization Manual рекомендует использовать `test` вместо 
`cmp` для сравнения регистра с нулём.

Ещё следует упомянуть об одном трюке с `xor`. Как вы знаете, 
`a XOR a = 0`. Пользуясь этой особенностью, `xor` часто применяют для 
обнуления регистров:

```
xorl  %eax, %eax
/* теперь %eax == 0 */
```

Почему применяют `xor` вместо `mov`? Команда `xor` короче, а значит, 
занимает меньше места в процессорном кэше, меньше времени тратится на 
декодирование, и программа выполняется быстрее. Но эта команда 
устанавливает флаги. Поэтому, если вам нужно сохранить состояние 
флагов, применяйте `mov`.

Иногда для обнуления регистра применяют команду `sub`. Помните, она 
тоже устанавливает флаги.

```
subl  %eax, %eax
/* теперь %eax == 0 */
```

К логическим командам также можно отнести команды сдвигов:

```
/* Shift Arithmetic Left/SHift logical Left */
sal/shl количество_сдвигов, назначение

/* SHift logical Right */
shr     количество_сдвигов, назначение 

/* Shift Arithmetic Right */
sar     количество_сдвигов, назначение
```

количество_сдвигов может быть задано непосредственным значением или 
находиться в регистре `%cl`. Учитываются только младшие 5 бит 
регистра `%cl`, так что количество сдвигов может варьироваться в 
пределах от 0 до 31.

Принцип работы команды `shl`:

```
					До сдвига:
+---+     +----------------------------------+
| ? |     | 10001000100010001000100010001011 |
+---+     +----------------------------------+
Флаг CF    Операнд

					Сдвиг влево на 1 бит:
+---+     +----------------------------------+
| 1 | <-- | 00010001000100010001000100010110 | <-- 0
+---+     +----------------------------------+
Флаг CF    Операнд

					Сдвиг влево на 3 бита:
+----+   +---+     +----------------------------------+
| 10 |   | 0 | <-- | 01000100010001000100010001011000 | <-- 000
+----+   +---+     +----------------------------------+
Улетели  Флаг CF    Операнд
в никуда
```

Принцип работы команды `shr`:

```
До сдвига:
+----------------------------------+     +---+
| 10001000100010001000100010001011 |     | ? |
+----------------------------------+     +---+
Операнд                                  Флаг CF

Логический сдвиг вправо на 1 бит:
	  +----------------------------------+     +---+
0 --> | 01000100010001000100010001000101 | --> | 1 |
	  +----------------------------------+     +---+
	  Операнд                                  Флаг CF

Логический сдвиг вправо на 3 бита:
		+----------------------------------+     +---+  +----+
000 --> | 00010001000100010001000100010001 | --> | 0 |  | 11 |
		+----------------------------------+     +---+  +----+
		Операнд                                 Флаг CF Улетели
												в никуда
```

Эти две команды называются командами логического сдвига, потому что 
они работают с операндом как с массивом бит. Каждый «выдвигаемый» бит 
попадает в флаг `cf`, причём с другой стороны операнда «вдвигается» 
бит 0. Таким образом, в флаге `cf` оказывается самый последний 
«выдвинутый» бит. Такое поведение вполне допустимо для работы с 
беззнаковыми числами, но числа со знаком будут обработаны неверно 
из-за того, что знаковый бит может быть потерян.

Для работы с числами со знаком существуют команды арифметического 
сдвига. Команды `shl` и `sal` выполняют полностью идентичные действия,
так как при сдвиге влево знаковый бит не теряется (расширение 
знакового бита влево становится новым знаковым битом). Для сдвига 
вправо применяется команда `sar`. Она «вдвигает» слева знаковый бит 
исходного значения, таким образом сохраняя знак числа:

```
До сдвига:
+----------------------------------+     +---+
| 10001000100010001000100010001011 |     | ? |
+----------------------------------+     +---+
Операнд                                  Флаг CF
старший бит равен 1 ==>
	==> значение отрицательное ==>
		==> "вдвинуть" бит 1 ---+
								|
+-------------------------------+
|
V       Арифметический сдвиг вправо на 1 бит:
	  +----------------------------------+     +---+
1 --> | 11000100010001000100010001000101 | --> | 1 |
	  +----------------------------------+     +---+
	  Операнд                                 Флаг CF

		Арифметический сдвиг вправо на 3 бита:
		+----------------------------------+     +---+  +----+
111 --> | 11110001000100010001000100010001 | --> | 0 |  | 11 |
		+----------------------------------+     +---+  +----+
		Операнд                                 Флаг CF Улетели
														в никуда
```

Многие программисты Си знают об умножении и делении на степени двойки 
(2, 4, 8…) при помощи сдвигов. Этот трюк отлично работает и в 
ассемблере, используйте его для оптимизации.

Кроме сдвигов обычных, существуют циклические сдвиги:

```
/* ROtate Right */
ror   количество_сдвигов, назначение

/* ROtate Left */
rol   количество_сдвигов, назначение
```

Объясню на примере циклического сдвига влево на три бита: три старших 
(«левых») бита «выдвигаются» из регистра влево и «вдвигаются» в него 
справа. При этом в флаг cf записывается самый последний «выдвинутый» 
бит.

Принцип работы команды `rol`:

```
До сдвига:
+---+         +----------------------------------+
| ? |         | 10001000100010001000100010001011 |
+---+         +----------------------------------+
Флаг CF        Операнд
													  
				Циклический сдвиг влево на 1 бит:
+---+  1    1 +----------------------------------+
| 1 | <--+--- | 00010001000100010001000100010111 | ---+
+---+    |    +----------------------------------+    |
Флаг CF  V    Операнд                                 ^
		 |                                            |
		 +------------------->--->--->----------------+
			1

				Циклический сдвиг влево на 3 бита:
+---+  0  100 +----------------------------------+
| 0 | <--+--- | 01000100010001000100010001011100 | ---+
+---+    |    +----------------------------------+    |
Флаг CF  V    Операнд                                 ^
		 |                                            |
		 +------------------->--->--->----------------+
			100
```

Принцип работы команды `ror`:

```
До сдвига:
+----------------------------------+         +---+
| 10001000100010001000100010001011 |         | ? |
+----------------------------------+         +---+
Операнд                                     Флаг CF

Циклический сдвиг вправо на 1 бит:
+----------------------------------+ 1    1  +---+
+--- | 11000100010001000100010001000101 | ---+--> | 1 |
|    +----------------------------------+    |    +---+
^    Операнд                                 V   Флаг CF
|                                            |
+-------------------<---<---<----------------+
											1
																																            Циклический сдвиг вправо на 3 бита:
+----------------------------------+ 011  0  +---+
+--- | 01110001000100010001000100010001 | ---+--> | 0 |
|    +----------------------------------+    |    +---+
^    Операнд                                 V   Флаг CF
|                                            |
+-------------------<---<---<----------------+
										011
```

Существует ещё один вид сдвигов — циклический сдвиг через флаг `cf`. 
Эти команды рассматривают флаг `cf` как продолжение операнда.

```
/* Rotate through Carry Right */
rcr   количество_сдвигов, назначение 

/* Rotate through Carry Left */
rcl   количество_сдвигов, назначение
```

Принцип работы команды `rcl`:

```
До сдвига:
+---+      +----------------------------------+
| X |      | 10001000100010001000100010001011 |
+---+      +----------------------------------+
Флаг CF     Операнд
																  
				Циклический сдвиг влево через CF на 1 бит:
  X  +---+      +----------------------------------+
+-<- | 1 | <--- | 0001000100010001000100010001011X | ---+
|    +---+      +----------------------------------+    |
V   Флаг CF     Операнд                                 ^
|                                                       |
+------------------------------>--->--->----------------+
																												   
				Циклический сдвиг влево через CF на 3 бита:
 X10 +---+      +----------------------------------+
+-<- | 0 | <--- | 01000100010001000100010001011X10 | ---+
|    +---+      +----------------------------------+    |
V   Флаг CF     Операнд                                 ^
|                                                       |
+------------------------------>--->--->----------------+
```

Принцип работы команды `rcr`:

```
До сдвига:
+----------------------------------+      +---+
| 10001000100010001000100010001011 |      | X |
+----------------------------------+      +---+
Операнд                                  Флаг CF

		Циклический сдвиг вправо через CF на 1 бит:
	 +----------------------------------+      +---+  X
+--- | X1000100010001000100010001000101 | ---> | 1 | ->-+
|    +----------------------------------+      +---+    |
^    Операнд                                  Флаг CF   V
|                                                       |
+-------------------<---<---<---------------------------+
																								 
		Циклический сдвиг вправо через CF на 3 бита:
	 +----------------------------------+      +---+ 11X
+--- | 11X10001000100010001000100010001 | ---> | 0 | ->-+
|    +----------------------------------+      +---+    |
^    Операнд                                  Флаг CF   V
|                                                       |
+-------------------<---<---<---------------------------+
```

Эти сложные циклические сдвиги вам редко понадобятся в реальной 
работе, но уже сейчас нужно знать, что такие инструкции существуют, 
чтобы не изобретать велосипед потом. Ведь в языке Си циклический сдвиг
производится приблизительно так:

```
int main()
{
	int a = 0x11223344;
	int shift_count = 8;

	a = (a << shift_count) | (a >> (32 - shift_count));

	printf("%x\n", a);
	return 0;
}
```
