#Введение

Окружение UNIX приспособлено как никакое другое именно для решения 
задач автоматизазации информационных процессов.

Центральное место для решения задач автоматизации занимают командные 
языки, такие как BASH, CSH, KSH, TCL и другие. 

Кроме командных языков, существуют также языки, условно обозначаемые 
здесь как языки программирования (потому что, вообще говоря, все 
рассматриваемые здесь языки можно назвать языками программирования). 
К этим языкам относятся C, C++, Pascal, Ada и ряд других. 
Предполагается, что студенты уже знакомы хотя бы с одним
языком этой группы, желательно C или C++.

Существуют также языки для решения задач обработки текстов (регулярные 
выражения, sed, awk, perl, flex, bison
и другие). 

Иногда желательно иметь средство автоматизации решения той или иной 
задачи с графическим интерфейсом. Для этого мы обсудим такое средство 
создания приложений с графическим интерфейсом, как Tk. Изначально это
было расширение языка TCL; впоследствии появились его переносы на ряд 
других скриптовых языков. Оно позволяет
создавать программы с графическим интерфейсом при помощи скриптов, 
т. е. текстовых файлов на командном языке.

Одной из отличительных особенностей UNIX, по крайней мере на начальном 
этапе ее использования была доступность документации по почти всем ее 
средствам непосредственно во время работы с системой.

Первая и древнейшая команда для этой цели называется `man`. В 
простейшем случае она вызывается следующим образом: `man слово`. 
В качестве слова выступает название той сущности, справку по которой Вы
хотите получить. Это может быть команда, процедура языка C, имя 
конфигурационного или специального, т. е. представляющего некоторое
устройство, файла и т. д.

Листать этот файл можно вперед и назад стрелками вверх/вниз (построчно)
и клавишами PgUp/PgDn (постранично). Также реализована возможность 
поиска интересующей Вас строки. Для этого нужно нажать `/`, затем 
ввести искомую строку и нажать Enter. Если эта строка встречается 
несколько раз, перейти к следующему вхождению можно, нажав `n`. 
Вернуться в самое начало файла можно, нажав `Home`, перейти в конец — 
`End`. Для выхода из просмотра справочной информации достаточно нажать 
`q`.

У команды `man` есть несколько разделов. Раздел 1 содержит информацию о
командах, 2 — о системных вызовах, т. е. процедурах, реализованных в 
операционной системе и позволяющих, например, работать с файлами и 
папками, 3 — о функциях языка C, 4 — о специальных файлах, 5 — о 
форматах конфигурационных файлов. Если при вызове команды `man` раздел 
не указан, информация ищется во всех разделах и выдается первый
найденный файл. 

Команда `man` обычно (хотя и не всегда) выдает достаточно краткую 
справку, содержащую описание опций той или иной команды. Гораздо более 
полную информацию о командах и не только можно получить по команде 
`info`.

Кроме `man` и `info`, в Linux имеется еще ряд команд 
информационно-справочного характера. Одна из важнейших команд такого 
рода называется `file`. Она позволяет узнать тип файла, исходя из его 
содержимого, а не расширения имени, как обычно определяется тип файла в
Windows. Эта команда бывает полезна, если по каким-то причинам
имя файла оказалось повреждено или утеряно, если расширение его имени 
Вам неизвестно или неинформативно

Пример.

```
file /lib/libc-2.22.so
```

Также полезной является команда `which`. Она выдает полный путь для 
исполняемого файла указанной команды.

Кроме команд, требующих точного знания названия интересующей Вас 
команды, имеются две утилиты поиска по заголовкам страниц руководства. 
Это утилиты `whatis` и `apropos`. Они обе ищут ключевые слова в 
заголовках, но правила соответствия у `whatis` жестче, чем у `apropos`,
поэтому обычно вывод `whatis` гораздо короче. Сначала надо
использовать его, и если он ничего не нашел, то `apropos`.

Из информационных команд еще уместно упомянуть здесь команду `uname`, 
выдающую информацию о системе. Обычно она используется с опцией `-a` и
выдает архитектуру компьютера, версию ядра системы, дату и время его
компиляции и некоторую другую полезную информацию. Это бывает полезно,
поскольку загрузчик `grub`, обычно обеспечивающий загрузку linux, 
иногда выдает версию ядра неверно.

Также полезным является текстовый файл `/etc/issue` — там обычно 
содержится название и версия установленного дистрибутива linux.

#Командные языки

В отличие от Windows, где имеется только одна программа для работы из 
командной строки `cmd.exe`, в любом современном и достаточно полном 
дистрибутиве Linux имеется несколько командных интерпретаторов на 
выбор. Наиболее мощным из них является BASH, и именно он и 
используется по умолчанию. Однако можно изменить свой командный
интерпретатор, указав полный путь файла, содержащего его программу, в 
файле `/etc/passwd`. 

Всякая вводимая с клавиатуры команда имеет определенную структуру. 
Прежде всего скажем, что введенная с клавиатуры команда 
рассматривается командным интерпретатором как набор отдельных слов. 
Чаще всего слова отделяются друг от друга пробелами, однако бывают 
случаи, когда пробелы не являются разделителями слов — такие
случаи будут рассмотрены позже. Например, команда `ls -l file.txt` 
состоит из трех слов: «ls», «-l» и «file.txt». 

Например, у компиляторов семейства gcc имеется опция без параметров 
`-c`, которая означает «остановиться на этапе компиляции и не 
производить компоновку». Также имеется опция `-W` с параметром, 
пишущимся слитно, означающая выбор ситуаций, в которых должно 
выдаваться предупреждение (warning). Например, опция `-Wall` означает,
что предупреждение должно выдаваться во всех подозрительных случаях. 

В большинстве случаев, хотя и не всегда, односимвольные опции без 
параметров можно объединять для экономии числа набираемых символов. 
Например, команда `ls -al` делает то же самое, что и `ls -a -l`. 

Кроме собственно текста команды (имени и аргументов), командная строка
может содержать некоторые специальные конструкции, также управляющие 
поведением программы. К ним относятся конструкции переадресации 
ввода-вывода и организации программных конвейеров и управляющие 
конструкции. 

Например, можно продолжить команду на следующую строку, поставив в 
самом ее конце символ `\`. Таким образом одна команда может занимать 
несколько строк, если в конце каждой из них, кроме последней, стоит 
символ `\`. 

```
[mind@vipassana ~]$ echo Hello \
> world
Hello world
```

Оказывается, можно не только размещать одну команду на нескольких 
строках, но и наоборот, размещать несколько команд в одной командной 
строке. Для этого команды нужно разделять символом `;`.

Если нужно отменить специальный смысл небольшого числа символов, перед
каждым из них нужно поставить символ `\`. Это работает в том числе и 
для пробелов, т. е. конструкция из `\` и следующего за ним пробела 
воспринимается как символ пробела, являющийся частью аргумента 
команды, а не разделяющий аргументы. Конструкция `\\` воспринимается 
как один символ `\`.

Команда `> file_name` создает новый файл с именем `file_name`. 
Результат аналогичен команде `touch file_name`.

Если нужно лишить специального смысла большое количество символов, 
предварять каждый из них символом `\` может быть утомительно. В этом 
случае можно заключить весь аргумент команды, содержащий специальные 
символы, в двойные или одинарные кавычки. Разница между ними только в 
том, какой набор специальных символов будет лишаться своего 
специального смысла. Одинарные кавычки в этом смысле гораздо мощнее, 
т. е. внутри одинарных кавычек теряют свой специальный смысл гораздо 
больше специальных символов.

Иногда требуется сохранить вывод той или иной программы в файле. Для 
этого в BASH предусмотрены конструкции, называемые переадресацией 
вывода. Чтобы просто записать вывод той или иной команды в файл, к 
тексту команды достаточно приписать текст `> имя_файла` . Например, 
чтобы сохранить список файлов из текущей папки в файле `list.txt`, 
достаточно выполнить команду `ls > list.txt`. При этом предыдущее 
содержимое файла теряется, т. е. еще **до начала работы** команды файл
**усекается до нулевой длины**. Если же нужно дописать вывод команды в
конец уже существующего файла, сохранив его содержимое, нужно 
воспользоваться конструкцией `>>`, так что предыдущая команда в этом 
варианте (дописывающая список файлов из текущей папки в конец файла 
`list.txt`) будет выглядеть так: `ls >> list.txt`.

Сказанное в последнем абзаце можно использовать, например, для того, 
чтобы объединить содержимое нескольких файлов в один при помощи 
команды `cat`. Например, команда, которая записывает подряд содержимое
файлов `file.txt` и `file1.txt` в файл `file2.txt`, будет выглядеть 
так: `cat file.txt file1.txt > file2.txt`. Однако, команда 
`cat file.txt file1.txt > file.txt` будет делать совсем не то, что 
предполагалось. Вместо того, чтобы приписывать содержимое `file1.txt` 
к файлу `file.txt`, она просто скопирует `file1.txt` в `file.txt`, 
поскольку сначала (еще до начала работы `cat`) `file.txt` будет 
сброшен до нулевой длины. Правильная команда, приписывающая 
`file1.txt` к `file.txt`, выглядит так: `cat file1.txt >> file.txt`.

Для перенаправления в файл того вывода, который посылался в `stderr`, 
используются следующие конструкции: `2> имя_файла` для перезаписи 
указанного файла и `2>> имя_файла` для дописывания вывода программы в 
конец.

Аналогично можно перенаправить и ввод информации в программу, чтобы 
вводимая программой информация бралась не с клавиатуры, а из файла или
из самой командной строки. Для этого существуют три конструкции.
Первая конструкция выглядит как `< имя_файла`. При ее использовании 
все выглядит так, как если бы содержимое указанного файла было бы 
набрано на клавиатуре.

Вторая конструкция выглядит как `<< end`. В этом случае пользователь
набирает вводимые данные, и признаком конца ввода служит строка, 
содержащая только тот текст, который был обозначен словом `end`. 
Например, если ввод выглядел как

```
cat << special
apple
orange
pear
special
```

то на вход команды `cat` поступит

```
apple
orange
pear
```

Наконец, последний вариант выглядит как `<<< data`. В этом случае 
данные, подаваемые на вход программы, содержатся непосредственно в 
командной строке.

В BASH возможны и более сложные манипуляции с потоками ввода и вывода.
Вообще, у каждого потока имеется дескриптор — небольшое целое число, 
указывающее на использование данного потока. Обычно, дескриптор stdin 
— 0, stdout — 1 и stderr — 2 (именно это 2 и имеется в виду в 
конструкции для перенаправления stderr `2>`). Однако имеется 
возможность открывать и использовать и другие потоки (дескрипторы до 
9 включительно). Для этого можно воспользоваться командой `exec`, в 
частности дающей возможность глобального перенаправления потоков 
(перенаправление непосредственно в тексте команды распространяется 
только на эту команду): `exec 4< имя_файла`. Такая конструкция
откроет на чтение поток с дескриптором 4 и свяжет его с указанным 
файлом, после чего им можно будет пользоваться в последующих командах 
до тех пор, пока он не будет закрыт явно командой `exec 4<&-`.

Эта возможность получает особую силу вместе с указаниями на 
дублирование дескрипторов при помощи конструкции `n>&m`, где n и m — 
дескрипторы. Такая конструкция означает, что весь вывод в поток с 
дескриптором n должен быть перенаправлен в поток с дескриптором m 
(существует аналогичная конструкция и для ввода). В одной и
той же команде такая конструкция может встречаться многократно, и 
порядок следования таких конструкций имеет значение, так как они 
обрабатываются **слева направо**. 

Например, команда `ls -l > output.txt 2>&1` выдаст весь вывод и в 
stdout, и в stderr в файл `output.txt`, поскольку сначала stdout 
связывается с файлом, и затем дублируется вывод из stderr в тот же 
самый файл. С другой стороны, команда `ls -l 2>&1 > output.txt` 
выдаст в файл output.txt только тот вывод, который шел в stdout, 
поскольку когда stderr перенаправлялся туда же, куда и stdout, stdout 
еще не был связан с файлом.

Пример. Следующая конструкция «меняет местами» stdout и stderr.

```
exec 3>&2
ls -l 2>&1 >&3
exec 3>&-
```

Имеется и еще одно средство для перенаправления ввода и вывода команд,
так называемый программный конвейер. Он выглядит как набор команд, 
соединенных при помощи разделителя `|`. При этом стандартный вывод 
предыдущей команды в конвейере связывается с каналом (до разбора любых
перенаправлений в этой команде), и ввод последующей команды 
связывается с тем же каналом, так что по умолчанию стандартный вывод 
предыдущей команды поступает на стандартный ввод следующей. При этом 
конструкции перенаправления ввода или вывода могут менять это 
поведение.

В качестве дополнительных возможностей можно указать на открытие файла
для чтения и записи конструкцией `дескриптор<> имя_файла`, а также 
конструкции `<(скрипт)` и `>(скрипт)`. Две последние конструкции 
запускают указанный в них скрипт, связывая его вывод (соответственно, 
ввод) с некоторым дескриптором, и затем подставляют указание на файл с
данным дескриптором в то место команды, где стояла указанная 
конструкция. Эти конструкции упрощают описание сложных взаимодействий 
между командами.

Напоследок в данной теме можно сказать, что в UNIX имеется такая 
разновидность файлов, как `fifo` (запись идет с одного конца, а чтение
— с другого, классическая очередь). Создаются такие «файлы» командой 
`mkfifo name`, и их тоже можно использовать в конструкциях 
перенаправления ввода и вывода.

Команда, позволяющая разрезать файлы на части называется `split`. Ее 
параметрами являются имя разрезаемого файла и префикс имени для 
результирующих файлов, т. е. имена результирующих файлов начинаются с 
указанного префикса, к которому приписываются окончания `aa`, `ab`, 
..., `az`, `ba`, ..., `zz` (по умолчанию длина окончаний 2, но опция
`-a` число позволяет задать это число самому). Кроме того, размер всех
частей, кроме последней, определяется опциями (до параметров): `-b` 
число определяет размер в байтах, а `-l` число определяет размер в 
строках (задавать и то и другое одновременно нельзя).

В Linux имеются также две команды для сравнения файлов. Для текстовых 
файлов предусмотрена команда `diff` (ее параметрами являются имена 
сравниваемых файлов). Для совпадающих файлов она не выдает ничего, а 
для различающихся — какие преобразования претерпели строки первого 
файла, чтобы получился второй, т. е. какие строки из первого файла 
надо убрать, какие изменить и какие добавить.

Для сравнения двоичных файлов предусмотрена команда `cmp`; смысл ее 
параметров такой же, как у `diff`. 

##Print a file skipping X lines in Bash

you need tail.

```
$ tail great-big-file.log
< Last 10 lines of great-big-file.log >
```

if you really need to SKIP a particular number of lines, use

```
$ tail -n+<First line to Print> <filename>
< filename, excluding first so many lines. >
```

That is, if you want to skip N lines, you start printing line N+1,

If you want to just see the last so many lines, omit the "+":

```
$ tail -n<Lines to show> <filename>
< last so many lines of file. >
```

При работе с файлами часто возникает необходимость указывать несколько
файлов, имена которых похожи друг на друга. Для этой цели в BASH 
имеется механизм шаблонов. В шаблоне символ `*` означает любую строку,
`?` означает любой, но ровно один символ, и конструкция `[...]` 
означает любой символ из числа заключенных между квадратными скобками.
Например, шаблону `a*` соответствуют все имена файлов, начинающиеся на
букву `a` (в том числе с любыми расширениями). Шаблону `[abc]x` будут 
соответствовать имена файлов `ax`, `bx`, `cx`. Если в каком-либо из 
слов команды встречается хотя бы одна из таких конструкций, BASH 
автоматически заменяет это слово на список соответствующих ему как 
шаблону имен файлов. При этом шаблоны могут содержать не только имена 
файлов, но также пути. Например, слово `a*/b*` будет заменено на 
список всех имеющихся путей, соответствующих данному шаблону, т.е. 
строк, состоящих из имени подпапки текущей папки, начинающегося на 
букву `a`, затем символа `/`, затем имени файла или папки, лежащих в 
этой подпапке, имя которых начинается с `b`. Однако, область действия 
символа `*` в шаблоне ограничена именем одной папки или файла, т.е. 
`*` не может соответствовать строке, содержащей разделитель имен папок
`/`. Шаблоны такого рода можно указывать в качестве параметров любой 
команды, понимающей несколько имен файлов в том месте командной 
строки, где стоит шаблон. Например, `ls *x` выдаст список имен файлов,
кончающихся на `x`.

Кроме того, имеется возможность явно указать набор строк, которые 
должны быть использованы в определенном месте слова. Для этого 
используются фигурные скобки, в которых эти строки перечислены через 
запятую. Например, слово `a{b1,c2,d3}x` превратится в `ab1x ac2x ad3x`
. Отличие этой конструкции от предыдущих состоит в том, что полученные
в результате такой замены слова не обязаны быть именами существующих 
файлов. Также, эта конструкция может быть вложенной сама в себя, 
например слово `a{b{c,d},e}x` превращается в `abcx abdx aex`.

Для подсчета символов, слов и строк в текстовых файлах, существует 
команда `wc`.

Для запуска команды в фоновом режиме нужно поставить в конец командной
строки символ `&`.

Команда `sleep` с единственным параметром ждет указанное число секунд 
и затем завершается.

Так же, как правило, интерактивную программу можно приостановить 
комбинацией клавиш `C-Z`. Выполнение приостановленной таким образом 
программы может быть продолжено в интерактивном (командой `fg %номер`)
, в фоновом — `bg %номер` режимах.

Для вывода списка всех запущенных в системе процессов используется 
команда `ps`. Она выводит по одной строке на каждый процесс, 
содержащей следующую информацию: PID, с какого терминала запущен 
процесс, сколько времени он работает (считается только время активной 
работы данного процесса, но не время простоя в ожидании, например,
завершения работы некоторых других процессов), какой командой этот 
процесс запущен (обычно выдается только имя команды, без параметров 
командной строки). По умолчанию (без дополнительных опций) выводятся 
только процессы, относящиеся к данной сессии. Чтобы вывести информацию
о всех процессах, нужно дать опцию `-e`.

Список запущенных работ можно получить по команде `jobs`.

Каждый выполняющийся в операционной системе Linux процесс может сам 
порождать новые процессы. Если один процесс порождает другой, то 
породивший называется родительским, а порожденный — дочерним. 
Отношение порождения накладывает некоторую структуру на множество 
процессов, увидеть которую позволяет команда `pstree`. Она выводит 
информацию о процессах в виде дерева, в котором каждый процесс имеет в
качестве сыновей те процессы, которые он породил. Для экономии места в
выводе команды `pstree` одинаковые поддеревья братьев, т.е. сыновей 
одного процесса, склеиваются с указанием кратности.

Каждый запущенный процесс в системе имеет такую важную характеристику,
как **приоритет**. В Linux это целое число от -20 (наивысший приоритет
) до 19 (наинизший). Чем выше приоритет, тем больше шансов у 
обладающего им процесса получить процессорное время для своего 
выполнения. Механизм приоритетов позволяет иметь в фоновом режиме 
большие вычислительные задачи, не замедляющие работу интерактивных 
программ, поскольку они выполняются только в том случае, если у 
системы нет другой работы. Для управления приоритетами существует 
команда `nice`, позволяющая указывать приоритет для вновь запускаемой 
программы. Если эта команда запускается без параметров, она выдает 
текущий уровень приоритета, на моей системе это 0. Если нужно 
запустить некоторую команду с другим уровнем приоритета, нужно дать 
опцию `-n сдвиг`, и затем текст команды. Сдвиг — это целое число, 
добавляемое к текущему уровню приоритета, чтобы получить тот уровень, 
на котором запускается команда-параметр.

Например, команда `nice -n 5 gcc *.cpp` означает «запустить команду 
`gcc *.cpp` с уровнем приоритета, равным 5 + текущий уровень 
приоритета». Более того, Linux позволяет менять приоритет уже 
запущенных программ при помощи команды `renice приоритет список_PID`. 
Например, команда `renice 1 2945` устанавливает в 1 приоритет процесса
, PID которого равен 2945. Обычные пользователи (не суперпользователь)
могут менять приоритеты только своих процессов, причем только в худшую
сторону.


запись в файл нескольких строк интерактивно

```
cat << end-of-input > result.txt
table
chair
sofa
end-of-input
```

Существует также команда `chown` для смены владельца файла. Раньше 
хозяин мог подарить свой файл кому угодно, теперь пользоваться этой 
командой может только root.

Команда expr предназначена для вычисления арифметических выражений. 
Ее параметрами являются элементарные части вычисляемого выражения, 
такие как числа и знаки операций, скобки. Например, команда 
`expr 3 + 5` вычисляет сумму 3 и 5, причем опустить разделяющие их 
пробелы нельзя.

Некоторые символы нужно экранировать: `expr 2 \* 7`

Команда `dc` представляет собой калькулятор произвольной точности, 
вычисляющий выражения, записанные в обратной польской записи.

Для более-менее сложных расчетов существует команда `bc` — 
интерпретируемый язык программирования, по синтаксису напоминающий C.

Следующая полезная команда называется `find`. Она предназначена для 
поиска файлов.

Имеется еще одна полезная команда, которая называется `xargs`. Она 
принимает в качестве параметров командную строку некоторой другой 
команды и делает следующее: читает со стандартного ввода 
последовательность строк и дополняет ими как аргументами ту командную 
строку, которую получила в качестве аргументов, до некоторой разумной 
длины, и затем запускает полученную команду, делая так до тех пор, 
пока стандартный ввод не закончится.

Следующая полезная команда называется `indent`. Параметром ее является
имя файла; она автоматически расставляет символы перевода строки и 
пробелы в начале строк, чтобы программа выглядела красиво.

В Linux имеются также две весьма удобные утилиты для вычисления 
контрольной суммы: `md5sum` и `sha1sum`.

Очередная полезная команда называется `pr`. Она позволяет печатать 
файлы в несколько столбцов, их число определяется опцией `-число`, 
например `-2` означает два столбца.

Следующая полезная команда, обсуждаемая здесь, — `sync`. Она 
записывает все системные буфера на диск, поэтому если система повиснет
и будет принудительно выключена, записанные на диск данные 
не пропадут.

Для отсылки и просмотра электронной почты существует команда `mail`.
Синтаксис ее для этой цели таков: `mail -s тема адрес источник`. Здесь
адрес — обычный адрес электронной почты, но если почта отсылается 
пользователю того же компьютера, то достаточно указать его 
регистрационное имя. Под источником здесь понимается один из способов 
переадресации ввода. Например, команда `mail -s test root < message` 
пошлет суперпользователю электронное письмо с темой test, текст 
которого будет взят из файла `message`.

Как говорилось раньше, команда `mail` умеет еще и читать почту, для 
чего она должна быть запущена без параметров. Она выводит приглашение,
и выполняет вводимые команды. Пустая команда означает «читать 
очередное сообщение», `d` — удалить, `q` — выйти.

Можно также обмениваться мгновенными сообщениями при помощи команды 
`write`. Ее синтаксис следующий: `write пользователь терминал`. Сам 
текст сообщения читается из стандартного ввода, но ввод может быть 
переадресован.

Запустите еще одно приложение терминала, при помощи команды `who` 
выясните названия запущенных терминалов. С одного из них пошлите 
сообщение на другой и вызвав его окно, убедитесь, что сообщение дошло.

В BASH имеется также удобное средство для измерения времени работы 
некоторой команды. Чтобы выяснить, сколько времени работала команда, 
нужно в начале командной строки поставить слово `time`.

команда test

```
test -f file && echo это файл
```

Кроме условий, связанных с файлами, в BASH возможна проверка 
арифметических условий, для чего существует арифметическая команда. Ее
синтаксис таков: `((выражение))` . Синтаксис похож на арифметическую 
подстановку, но без знака `$` спереди. В отличие от арифметической 
подстановки, это — полноценная команда; она вычисляет свое выражение и
завершается успешно, если его результат отличен от нуля и неуспешно, 
если результат нулевой.

В BASH есть также некоторая управляющая конструкция, не имеющая 
аналогов в традиционных языках программирования и представляющая собой
некое сочетание операторов выбора и цикла. Она имеет синтаксис 

```
select имя in строка; do команды; done 
```

Например, следующая команда выводит на экран имена всех файлов в 
текущей папке, начинающиеся на букву `a`, и позволяет пользователю 
просмотреть более подробную информацию о некоторых из них, введя 
номера соответствующих файлов

```
select A in a*; do stat $A; done
```

Пользователь может прекратить этот процесс, ответив на очередной
вопрос комбинацией клавиш `C-D`. 

Наконец, в BASH есть аналоги составных операторов из традиционных 
языков программирования. Один из них — последовательность команд в 
круглых скобках рассматривается как одна команда, выполняемая в своей 
копии BASH. Если вместо круглых скобок использовать фигурные (они 
должны отделяться от команд пробелами, и после последней команды 
должна стоять точка с запятой) — результат будет почти тем же, но 
такая последовательность команд будет выполнена в **той же** копии 
BASH, которая выполняет объемлющую команду, т. е. новая копия BASH не
будет запущена.


Присваивание значения переменной выглядит следующим образом: 
`имя_переменной=значение`.

Когда переменная больше не нужна, можно освободить занимаемую ею 
память командой `unset имя_переменной`.

Если конструкция извлечения значения переменной стоит вплотную к 
некоторому тексту, начинающемуся с буквы, так что непонятно, где 
кончается имя переменной и начинается последующий текст — имя 
переменной нужно заключать в фигурные скобки; так, если нужно извлечь 
значение переменной `XYZ` вплотную перед текстом `UVW`,
нужно написать `${XYZ}UVW`.

Если извлеченное значение переменной должно быть частью параметра 
команды или присваиваемого значения, содержащего пробелы, конструкция 
извлечения значения переменной вполне может встречаться внутри 
кавычек. Например, если переменная `A` имеет значение `Hello`, то 
присваивание `B="$A world!"` запишет в переменную `B` текст
`Hello world!`.

в BASH существуют и другие конструкции для извлечения значения 
переменной:

1\. **Косвенное обращение**. Конструкция `${!имя}` извлекает значение 
указанной переменной, рассматривает его как имя другой переменной, и 
извлекает ее значение, которое и считается значением этой конструкции.

2\. **Подстановка значений по умолчанию**. Конструкция `${имя:-слово}`
извлекает значение из указанной переменной, если такая переменная 
существует и ее значение не является пустой строкой. В противном 
случае подставляется указанное слово.

3\. Присваивание значений по умолчанию осуществляется при помощи 
конструкции `${имя:=слово}`, которая по смыслу похожа на предыдущую, 
но если указанная переменная не определена или имеет пустое значение, 
указанное слово становится ее новым значением.

4\. **Проверка наличия переменной**. Конструкция `${имя:?слово}` 
извлекает значение из указанной переменной, если такая переменная 
существует и ее значение не является пустой строкой. В противном 
случае указанное слово выдается в стандартный поток вывода сообщений 
об ошибках, и, если командный интерпретатор не был интерактивным, 
т. е. выполнял команды из файла, а не с клавиатуры, он завершается.

5\. **Извлечение подстроки.** В самом общем виде эта конструкция 
выглядит как `${имя:начало:длина}`. Значением ее является подстрока 
значения переменной, начинающаяся с позиции, заданной выражением 
«начало» (символы нумеруются с нуля) и имеющая указанную длину. 
Если `:длина` опущено, берется подстрока до конца строки. Если длина
указана, она должна быть неотрицательной. Начало может быть 
отрицательным; в этом случае оно отсчитывается от конца значения 
переменной.

6\. **Длина значения переменной** как строки вычисляется при помощи 
конструкции `${#имя}`.

7\. Извлечение значения переменной **без самого короткого начала**, 
соответствующего заданному шаблону, производится при помощи 
конструкции `${имя#шаблон}` . Шаблон строится по тем же правилам, что 
и при указании нескольких файлов одним словом. Такая конструкция, 
равно как и родственные ей конструкции, описанные ниже, в основном 
используется для манипуляции с именами файлов. Например, пусть в 
переменной `A` содержится путь; данная конструкция позволяет извлечь 
из переменной `A` этот путь без первой входящей в его состав папки 
таким образом: `${A#*/}`. Имеются еще три аналогичные конструкции: 
`${имя##шаблон}` — извлечь значение указанной переменной **без самого 
длинного начала**, соответствующего шаблону; `${имя%шаблон}` — 
извлечь значение указанной переменной **без самого короткого конца**, 
соответствующего шаблону; `${имя%%шаблон}` — извлечь значение 
указанной переменной без **самого длинного конца**, соответствующего 
шаблону

8\. Замена образца на некоторую строку при извлечении значения 
переменной выполняется при помощи конструкции `${имя/образец/строка}` . Образец строится по тем же правилам, что и при указании файлов; 
заменяется самая длинная подстрока, соответствующая образцу. Однако, 
если он начинается с символа `/`, то заменяются все вхождения текста, 
соответствующего образцу (в противном случае заменяется только первое 
вхождение).

Пример.

Написать и протестировать конструкцию, заменяющую в имени файла с 
путем 

1. расширение `.txt` на `.html`; 
Убедитесь в правильности результата.
2. любое расширение на `.html`;

Решение:

```
${HELLO%*.txt}.html
```

```
${HELLO%*.*}.html
```

Синтаксис арифметической подстановки таков: `$((выражение))`. Под 
выражением здесь понимается обычное арифметическое выражение, 
составленное из целых чисел, переменных (перед их именами здесь нет 
необходимости ставить знак `$`) и операций, как в языке C. Значением 
этой конструкции является результат выражения, который может быть 
использован в правой части присваивания, в параметрах команд и в 
строках, заключенных в кавычки. При этом, естественно, требуется, 
чтобы значения переменных, входящих в это выражение, представляли 
собой целые числа, а не произвольные строки. Например, команда 
`echo $((3+5))` вычислит указанное выражение и выведет его результат
на экран, а команда `I=$((I+1))` увеличит значение переменной `I` на 
единицу.

Часто также возникает необходимость присвоить переменной или 
использовать в параметре команды результат другой команды. Для этого 
существует так называемая командная подстановка. Эта конструкция имеет
(на выбор пользователя) два разных синтаксиса: 

```
`команда`
```

(здесь использована обратная одинарная кавычка, расположенная в левом 
верхнем углу клавиатуры, под тильдой) или `$(команда)` (скобки 
одинарные, в отличие от арифметической подстановки, где они двойные). 
Значением командной подстановки будет результат работы указанной 
команды, т. е. тот текст, который команда выводит в свой стандартный 
вывод.

Обычно, переменные, создаваемые в BASH, не видны в тех программах, 
которые запускаются из BASH. Для того, чтобы они стали видны, 
необходимо применить к ним команду `export` следующим образом: 
`export имена_переменных`.

Выведите на экран значение переменной `TERM` и сохраните его в 
переменной `A`. Присвойте переменной `TERM` значение `DUMB` (самый 
«тупой» терминал, который может только выводить обычные печатаемые 
символы на экран). Попробуйте запустить полноэкранный текстовый 
редактор vim. Что происходит? Верните старое значение `TERM` и 
попытайтесь запустить vim теперь. 

Следующей мы рассмотрим переменную `LANG`. Ее содержимое определяет 
используемые региональные стандарты, такие как используемый язык, 
конкретизированный страной, кодировку символов, формат представления 
чисел, дат, денежных сумм и т. п.

```
[mind@vipassana ~]$ echo $LANG
en_US.UTF-8
```

Обращение к элементу массива выглядит традиционным образом; для 
присваивания можно написать `массив[индекс]=...`, извлечь значение 
элемента массива можно конструкцией `${массив[индекс]}`.

##Функции и скрипты

Для извлечения значения параметров можно использовать все способы,
которые были описаны в связи с извлечением значений переменных. 
Простейший способ, описанный выше, годится только для параметров с 
номерами от 1 до 9. Так, конструкция `$12` означает первый параметр, 
за которым сразу стоит цифра 2; если нужен 12-й параметр, нужно писать
`${12}`.

Кроме конструкций, извлекающих значения индивидуальных параметров, 
существует набор способов получить некоторую информацию обо всех 
параметрах сразу:

  * Конструкция `$*` означает совокупность всех параметров, как 
  правило, разделенных пробелами.

  * Конструкция `$#` означает число параметров.

Существует также полезная команда `shift` с неотрицательным целым 
параметром. Она сдвигает все параметры на указанное число позиций 
влево; если число-параметр не указано, сдвиг выполняется на 1 позицию.

Например, после команды `shift 3` четвертый параметр становится 
первым, пятый — вторым, и т. д.

BASH поддерживает рекурсию, т. е. процедуры BASH могут вызывать самих 
себя, как непосредственно, так и через другие функции.
По умолчанию все переменные в BASH — глобальные, т. е. видимые всем 
процедурам. Если нужно иметь некоторые локальные переменные, их можно 
объявить при помощи команды `local`, перечислив в качестве параметров 
их имена.

Скрипты BASH могут быть запущены двумя способами:

  1. Как и всякая другая программа, при помощи указания имени скрипта 
  (возможно, с путем) и его параметров в командной строке. В этом 
  случае для обработки команд скрипта запускается отдельная копия 
  BASH.

  2. При помощи специальной команды `.` (ее параметрами являются имя 
  скрипта и его параметры). В этом случае скрипт запускается в той же 
  копии BASH, которая обрабатывает команду его запуска. Для такого 
  запуска скрипта первая строка с указанием BASH в качестве 
  интерпретатора не нужна.

Разница между этими способами запуска скрипта в том, что в первом 
случае изменения состояния командного интерпретатора, вызванные 
выполнением скрипта, по завершении этого выполнения теряются. 
Во втором случае они остаются в силе.

Пример.

Напишите скрипт, меняющий текущую папку на корневую. Запустите этот 
скрипт двумя способами, описанными выше. В чем разница?

Механизм передачи параметров скрипту практически совпадает с 
используемым для функций. Разница состоит в том, что конструкция `$0` 
означает имя скрипта (в случае скриптов), а для функций ее значение 
не меняется на имя вызванной функции.


